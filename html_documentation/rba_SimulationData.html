<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>rbatools.rba_SimulationData API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>rbatools.rba_SimulationData</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># python 2/3 compatibility
from __future__ import division, print_function
import sys
import os.path
import numpy
import pandas
import copy
import json
import jxmlease
import xml.etree.ElementTree as ET
import csv
from sbtab import SBtab

# package imports
import rba
from rbatools.data_block import DataBlock


class RBA_SimulationData(object):
    &#34;&#34;&#34;
    Class holding information on simulations with the model.
    Attributes
    ----------
    StructuralInformation : rbatools.rba_ModelStructure RBA_ModelStructure object.
         Model description
    SessionName : str
         Name of simulation session
    ProteinData : rbatools.data_block DataBlock object.
         Simulated protein levels
    ReactionData : rbatools.data_block DataBlock object.
         Simulated reaction data
    EnzymeData : rbatools.data_block DataBlock object.
         Simulated enzyme data
    ProcessData : rbatools.data_block DataBlock object.
         Simulated process machinery data
    MetaboliteConstraintData : rbatools.data_block DataBlock object.
         Simulation information on mass-balance constraints
    DensityConstraintData : rbatools.data_block DataBlock object.
         Simulation information on compartment-density constraints
    ProcessConstraintData : rbatools.data_block DataBlock object.
         Simulation information on process-capacity constraints
    EnzymeConstraintData : rbatools.data_block DataBlock object.
         Simulation information on enzyme-efficiency constraints
    Methods
    ----------
    __init__(StaticData)
        Initiates Simulation data object
    fromSimulationResults(Controller, session_name)
        Imports data from rbatools.RBA_Controler object
    fromJSON(inputString)
        Imports data from JSON string object
    toXML()
        Exports xml-file
    toJSON()
        Returns simulation data as JSON string
    exportSBtab()
        Exports SBtab files
    exportSBtab_OneFile()
        Exports simulation data in one single sbtab file
    exportCSV(deleteZerosRows=True)
        Exports simulation data as csv files
    exportEscherMap(type=&#39;fluxes&#39;)
        Exports input file for generation of Escher maps.
    exportProteoMap()
        Exports input file for the generation of Proteo maps from
        simulation data.
    &#34;&#34;&#34;

    def __init__(self, StaticData):
        &#34;&#34;&#34;
        Initiates Simulation data object
        Parameters
        ----------
        StaticData : rbatools.RBA_ModelStructure
        &#34;&#34;&#34;

        self.StructuralInformation = copy.deepcopy(StaticData)

        self.ProteinData = DataBlock()
        self.ProtoProteinData = DataBlock()
        self.ReactionData = DataBlock()
        self.ExchangeData = DataBlock()
        self.uniqueReactionData = DataBlock()
        self.EnzymeData = DataBlock()
        self.ProcessData = DataBlock()
        self.MetaboliteConstraintData = DataBlock()
        self.DensityConstraintData = DataBlock()
        self.EnzymeConstraintData = DataBlock()
        self.ProcessConstraintData = DataBlock()
        self.GeneralRunInfo = DataBlock()
        self.ObjectiveFunctionInfo = DataBlock()

        self.SessionName = &#39;&#39;

        self.ProteinData.fromDict({})
        self.ProtoProteinData.fromDict({})
        self.ReactionData.fromDict({})
        self.ExchangeData.fromDict({})
        self.uniqueReactionData.fromDict({})
        self.EnzymeData.fromDict({})
        self.ProcessData.fromDict({})
        self.MetaboliteConstraintData.fromDict({})
        self.DensityConstraintData.fromDict({})
        self.EnzymeConstraintData.fromDict({})
        self.ProcessConstraintData.fromDict({})
        self.GeneralRunInfo.fromDict({})
        self.ObjectiveFunctionInfo.fromDict({})

    def fromSimulationResults(self, Controller, session_name=&#39;&#39;):
        &#34;&#34;&#34;
        Imports data from rbatools.RBA_Controler object
        Parameters
        ----------
        Controller : rbatools.RBA_newControler
            Defines from which object to extract the data from
        session_name: str
            Defines the name of the session
            Is appended to the filenames generated by export methods.
        &#34;&#34;&#34;
        self.SessionName = session_name

        self.run_names = list(Controller.Results[&#39;ObjectiveValue&#39;])
        ObjDict = {}
        for run in list(Controller.Results[&#39;ObjectiveValue&#39;]):
            ObjDict.update({run: Controller.Results[&#39;ObjectiveValue&#39;].loc[&#39;ObjectiveValue&#39;, run]})

        SolutionType_Dict = {}
        for run in list(Controller.Results[&#39;SolutionType&#39;]):
            SolutionType_Dict.update(
                {run: Controller.Results[&#39;SolutionType&#39;].loc[&#39;SolutionType&#39;, run]})

        MuDict = {}
        for run in list(Controller.Results[&#39;Mu&#39;]):
            MuDict.update({run: Controller.Results[&#39;Mu&#39;].loc[&#39;Mu&#39;, run]})

        self.GeneralRunInfo.addEntries({&#39;ProblemType&#39;: SolutionType_Dict})
        self.GeneralRunInfo.addEntries({&#39;Mu&#39;: MuDict})
        self.GeneralRunInfo.addEntries({&#39;Obj_Val&#39;: ObjDict})

        for var in list(Controller.Results[&#39;ObjectiveFunction&#39;].index):
            if var not in self.ObjectiveFunctionInfo.Elements:
                self.ObjectiveFunctionInfo.Elements.update({var: {}})
            for run in list(Controller.Results[&#39;ObjectiveFunction&#39;]):
                self.ObjectiveFunctionInfo.Elements[var].update(
                    {run: Controller.Results[&#39;ObjectiveFunction&#39;].loc[var, run]})

        for exchange in list(Controller.Results[&#39;ExchangeFluxes&#39;].index):
            if exchange not in self.ExchangeData.Elements:
                self.ExchangeData.Elements.update({exchange: {}})
#            self.ExchangeData.Elements[exchange].update({&#39;ID&#39;: exchange})
            for run in list(Controller.Results[&#39;ExchangeFluxes&#39;]):
                self.ExchangeData.Elements[exchange].update(
                    {run: Controller.Results[&#39;ExchangeFluxes&#39;].loc[exchange, run]})

        for reaction in list(Controller.Results[&#39;Reactions&#39;].index):
            if reaction not in self.ReactionData.Elements:
                self.ReactionData.Elements.update({reaction: {}})
#            self.ReactionData.Elements[reaction].update({&#39;ID&#39;: reaction})
            for run in list(Controller.Results[&#39;Reactions&#39;]):
                self.ReactionData.Elements[reaction].update(
                    {run: Controller.Results[&#39;Reactions&#39;].loc[reaction, run]})

        for reaction in list(Controller.Results[&#39;uniqueReactions&#39;].index):
            if reaction not in self.uniqueReactionData.Elements:
                self.uniqueReactionData.Elements.update({reaction: {}})
#            self.uniqueReactionData.Elements[reaction].update({&#39;ID&#39;: reaction})
            for run in list(Controller.Results[&#39;uniqueReactions&#39;]):
                self.uniqueReactionData.Elements[reaction].update(
                    {run: Controller.Results[&#39;uniqueReactions&#39;].loc[reaction, run]})

        for enzyme in list(Controller.Results[&#39;Enzymes&#39;].index):
            if enzyme not in self.EnzymeData.Elements:
                self.EnzymeData.Elements.update({enzyme: {}})
#            self.EnzymeData.Elements[enzyme].update({&#39;ID&#39;: enzyme})
            for run in list(Controller.Results[&#39;Enzymes&#39;]):
                self.EnzymeData.Elements[enzyme].update(
                    {run: Controller.Results[&#39;Enzymes&#39;].loc[enzyme, run]})

        for process in list(Controller.Results[&#39;Processes&#39;].index):
            if process not in self.ProcessData.Elements:
                self.ProcessData.Elements.update({process: {}})
#            self.ProcessData.Elements[process].update({&#39;ID&#39;: process})
            for run in list(Controller.Results[&#39;Processes&#39;]):
                self.ProcessData.Elements[process].update(
                    {run: Controller.Results[&#39;Processes&#39;].loc[process, run]})

        for protein in list(Controller.Results[&#39;Proteins&#39;].index):
            if protein not in self.ProteinData.Elements:
                self.ProteinData.Elements.update({protein: {}})
#            self.ProteinData.Elements[protein].update({&#39;ID&#39;: protein})
            for run in list(Controller.Results[&#39;Proteins&#39;]):
                self.ProteinData.Elements[protein].update(
                    {run: Controller.Results[&#39;Proteins&#39;].loc[protein, run]})

        for protoprotein in list(Controller.Results[&#39;ProtoProteins&#39;].index):
            if protoprotein not in self.ProtoProteinData.Elements:
                self.ProtoProteinData.Elements.update({protoprotein: {}})
#            self.ProtoProteinData.Elements[protoprotein].update({&#39;ID&#39;: protoprotein})
            for run in list(Controller.Results[&#39;ProtoProteins&#39;]):
                self.ProtoProteinData.Elements[protoprotein].update(
                    {run: Controller.Results[&#39;ProtoProteins&#39;].loc[protoprotein, run]})

        for constr in list(Controller.Results[&#39;Constraints&#39;].index):
            if constr in list(self.StructuralInformation.MetaboliteConstraintsInfo.Elements.keys()):
                if constr not in self.MetaboliteConstraintData.Elements:
                    self.MetaboliteConstraintData.Elements.update({constr: {}})
#                self.MetaboliteConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.MetaboliteConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.DensityConstraintsInfo.Elements.keys()):
                if constr not in self.DensityConstraintData.Elements:
                    self.DensityConstraintData.Elements.update({constr: {}})
#                self.DensityConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.DensityConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.EnzymeConstraintsInfo.Elements.keys()):
                if constr not in self.EnzymeConstraintData.Elements:
                    self.EnzymeConstraintData.Elements.update({constr: {}})
#                self.EnzymeConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.EnzymeConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.ProcessConstraintsInfo.Elements.keys()):
                if constr not in self.ProcessConstraintData.Elements:
                    self.ProcessConstraintData.Elements.update({constr: {}})
#                self.ProcessConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.ProcessConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})

    def fromJSON(self, inputString):
        &#34;&#34;&#34;
        Imports data from JSON string object
        Parameters
        ----------
        inputString: json-string
        &#34;&#34;&#34;

        Block = json.loads(inputString)
        self.ReactionData = DataBlock()
        self.ProteinData = DataBlock()
        self.EnzymeData = DataBlock()
        self.ProcessData = DataBlock()
        self.MetaboliteConstraintData = DataBlock()
        self.DensityConstraintData = DataBlock()
        self.EnzymeConstraintData = DataBlock()
        self.ProcessConstraintData = DataBlock()
        self.ReactionData.fromDict(Block[&#39;ReactionData&#39;])
        self.ProteinData.fromDict(Block[&#39;ProteinData&#39;])
        self.EnzymeData.fromDict(Block[&#39;EnzymeData&#39;])
        self.ProcessData.fromDict(Block[&#39;ProcessData&#39;])
        self.MetaboliteConstraintData.fromDict(Block[&#39;MetaboliteConstraintData&#39;])
        self.DensityConstraintData.fromDict(Block[&#39;DensityConstraintData&#39;])
        self.EnzymeConstraintData.fromDict(Block[&#39;EnzymeConstraintData&#39;])
        self.ProcessConstraintData.fromDict(Block[&#39;ProcessConstraintData&#39;])

    def exportXML(self):
        &#34;&#34;&#34;
        Exports xml-file
        &#34;&#34;&#34;

        x = htmlStyle(self)
        root = ET.fromstring(jxmlease.emit_xml(x, encoding=&#39;utf-8&#39;))
        m = ET.tostring(root, &#39;utf-8&#39;)
        return(m)

    def exportSBtab(self, filename=None, add_links=False):
        &#34;&#34;&#34;
        Exports simulation data in one single sbtab file
        &#34;&#34;&#34;
        GeneralRunInfoTable = self.GeneralRunInfo.toSBtab(
            table_id=&#39;run_information&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Run information&#39;)
        GeneralRunInfoTable.filename = &#39;RunInfo.tsv&#39;
        GeneralRunInfoTable.change_attribute(
            &#39;Text&#39;, &#39;Growth rates mu and cellular objective values (by default: minimisation of total enzyme concentration).&#39;)
        # GeneralRunInfoTable.unset_attribute(&#39;Date&#39;)
        GeneralRunInfoTable.unset_attribute(&#39;SBtabVersion&#39;)

        ObjectiveFunctionDataTable = self.ObjectiveFunctionInfo.toSBtab(
            table_id=&#39;objective_coefficients&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Linear objective&#39;)
        ObjectiveFunctionDataTable.filename = &#39;ObjectiveFunctionData.tsv&#39;
        ObjectiveFunctionDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        ObjectiveFunctionDataTable.change_attribute(&#39;QuantityType&#39;, &#39;objective_coefficient&#39;)
        ObjectiveFunctionDataTable.change_attribute(
            &#39;Text&#39;, &#39;Coefficients in objective function (&lt;0 : maximisation , &gt;0 : minimisation)&#39;)
        # ObjectiveFunctionDataTable.unset_attribute(&#39;Date&#39;)
        ObjectiveFunctionDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ReactionDataTable = self.ReactionData.toSBtab(
            table_id=&#39;reaction_flux&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Reaction fluxes&#39;)
        ReactionDataTable.filename = &#39;ReactionData.tsv&#39;
        ReactionDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/(h*gDW)&#39;)
        ReactionDataTable.change_attribute(&#39;QuantityType&#39;, &#39;reaction_flux&#39;)
        ReactionDataTable.change_attribute(
            &#39;Text&#39;, &#39;Reaction fluxes obtained in the simulation runs (table columns).&#39;)
        # ReactionDataTable.unset_attribute(&#39;Date&#39;)
        ReactionDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        EnzymeDataTable = self.EnzymeData.toSBtab(
            table_id=&#39;enzyme_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Enzyme concentrations&#39;)
        EnzymeDataTable.filename = &#39;EnzymeData.tsv&#39;
        EnzymeDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
        EnzymeDataTable.change_attribute(&#39;QuantityType&#39;, &#39;enzyme_concentration&#39;)
        EnzymeDataTable.change_attribute(
            &#39;Text&#39;, &#39;Enzyme concentrations obtained in the simulation runs (table columns).&#39;)
        # EnzymeDataTable.unset_attribute(&#39;Date&#39;)
        EnzymeDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ProcessDataTable = self.ProcessData.toSBtab(
            table_id=&#39;machine_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Machine concentrations&#39;)
        ProcessDataTable.filename = &#39;ProcessData.tsv&#39;
        ProcessDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
        ProcessDataTable.change_attribute(&#39;QuantityType&#39;, &#39;machine_concentration&#39;)
        ProcessDataTable.change_attribute(
            &#39;Text&#39;, &#39;Macromolecular machine concentrations obtained in the simulation runs (table columns).&#39;)
        # ProcessDataTable.unset_attribute(&#39;Date&#39;)
        ProcessDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ProteinDataTable = self.ProteinData.toSBtab(
            table_id=&#39;protein_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Protein concentrations&#39;)
        ProteinDataTable.filename = &#39;ProteinData.tsv&#39;
        ProteinDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
        ProteinDataTable.change_attribute(&#39;QuantityType&#39;, &#39;protein_concentration&#39;)
        ProteinDataTable.change_attribute(
            &#39;Text&#39;, &#39;Protein concentrations obtained in the simulation runs (table columns).&#39;)
        # ProteinDataTable.unset_attribute(&#39;Date&#39;)
        ProteinDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        MetaboliteConstraintDataTable = self.MetaboliteConstraintData.toSBtab(
            table_id=&#39;metabolite_mass_balance_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Metabolite mass-balance dual values&#39;)
        MetaboliteConstraintDataTable.filename = &#39;MetaboliteConstraintData.tsv&#39;
        MetaboliteConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        MetaboliteConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        MetaboliteConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the metabolite mass-balance constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # MetaboliteConstraintDataTable.unset_attribute(&#39;Date&#39;)
        MetaboliteConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        DensityConstraintDataTable = self.DensityConstraintData.toSBtab(
            table_id=&#39;density_constraint_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Compartment density dual values&#39;)
        DensityConstraintDataTable.filename = &#39;DensityConstraintData.tsv&#39;
        DensityConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        DensityConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        DensityConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the density constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # DensityConstraintDataTable.unset_attribute(&#39;Date&#39;)
        DensityConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        EnzymeConstraintDataTable = self.EnzymeConstraintData.toSBtab(
            table_id=&#39;enzyme_capacity_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Enzyme capacity dual values&#39;)
        EnzymeConstraintDataTable.filename = &#39;EnzymeConstraintData.tsv&#39;
        EnzymeConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        EnzymeConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        EnzymeConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the enzyme-capacity constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # EnzymeConstraintDataTable.unset_attribute(&#39;Date&#39;)
        EnzymeConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ProcessConstraintDataTable = self.ProcessConstraintData.toSBtab(
            table_id=&#39;machine_capacity_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Machine capacity dual values&#39;)
        ProcessConstraintDataTable.filename = &#39;ProcessConstraintData.tsv&#39;
        ProcessConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        ProcessConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        ProcessConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the machine-capacity constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # ProcessConstraintDataTable.unset_attribute(&#39;Date&#39;)
        ProcessConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        if filename is not None:
            filename_SBtab = filename
        else:
            filename_SBtab = &#39;RBA_results&#39;

        if add_links:
            ReactionDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Reaction/&#39;+entry+&#39;!)&#39;)
                                                                     for entry in list(ReactionDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            ProcessDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Process/&#39;+entry+&#39;!)&#39;)
                                                                    for entry in list(ProcessDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            EnzymeDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Enzyme/&#39;+entry+&#39;!)&#39;)
                                                                   for entry in list(EnzymeDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            ProteinDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Protein/&#39;+entry+&#39;!)&#39;)
                                                                    for entry in list(ProteinDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            MetaboliteConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Compound/&#39;+entry+&#39;!)&#39;) for entry in list(MetaboliteConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            DensityConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Compartment/&#39;+entry+&#39;!)&#39;) for entry in list(DensityConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            ProcessConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Process/&#39;+entry+&#39;!)&#39;) for entry in list(ProcessConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            EnzymeConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Enzyme/&#39;+entry+&#39;!)&#39;) for entry in list(EnzymeConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)

            filename_SBtab += &#39;_HTML&#39;

        else:
            ReactionDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ReactionDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            ProcessDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ProcessDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            EnzymeDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(EnzymeDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            ProteinDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ProteinDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            MetaboliteConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(MetaboliteConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            DensityConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(DensityConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            ProcessConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ProcessConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            EnzymeConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(EnzymeConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)

        ReactionDataTable.remove_column(position=2)
        ProcessDataTable.remove_column(position=2)
        EnzymeDataTable.remove_column(position=2)
        ProteinDataTable.remove_column(position=2)
        MetaboliteConstraintDataTable.remove_column(position=2)
        DensityConstraintDataTable.remove_column(position=2)
        ProcessConstraintDataTable.remove_column(position=2)
        EnzymeConstraintDataTable.remove_column(position=2)

        self.Out = SBtab.SBtabDocument(name=&#39;rbatools_SimulationData_withLinks&#39;,
                                       sbtab_init=None, filename=str(filename_SBtab+&#39;.tsv&#39;))
        self.Out.add_sbtab(GeneralRunInfoTable)
        self.Out.add_sbtab(ObjectiveFunctionDataTable)
        self.Out.add_sbtab(ReactionDataTable)
        self.Out.add_sbtab(EnzymeDataTable)
        self.Out.add_sbtab(ProcessDataTable)
        self.Out.add_sbtab(ProteinDataTable)
        self.Out.add_sbtab(MetaboliteConstraintDataTable)
        self.Out.add_sbtab(DensityConstraintDataTable)
        self.Out.add_sbtab(EnzymeConstraintDataTable)
        self.Out.add_sbtab(ProcessConstraintDataTable)

        self.Out.change_attribute(&#39;DocumentName&#39;, &#39;RBA data&#39;)
        self.Out.name = filename
        self.Out.change_attribute(&#39;DocumentType&#39;, &#39;rba-simulation-data&#39;)
        self.Out.write()

    def getSBtabDoc(self):
        return self.Out

    def exportJSON(self):
        &#34;&#34;&#34;
        Returns simulation data as JSON string
        Returns
        -------
        JSON string
        &#34;&#34;&#34;

        Block = {&#39;ReactionData&#39;: self.ReactionData.Elements,
                 &#39;ProteinData&#39;: self.ProteinData.Elements,
                 &#39;EnzymeData&#39;: self.EnzymeData.Elements,
                 &#39;ProcessData&#39;: self.ProcessData.Elements,
                 &#39;MetaboliteConstraintData&#39;: self.MetaboliteConstraintData.Elements,
                 &#39;DensityConstraintData&#39;: self.DensityConstraintData.Elements,
                 &#39;EnzymeConstraintData&#39;: self.EnzymeConstraintData.Elements,
                 &#39;ProcessConstraintData&#39;: self.ProcessConstraintData.Elements}
        return(json.dumps(Block))

    def exportCSV(self, deleteZerosRows=True):
        &#34;&#34;&#34;
        Exports simulation data as csv files
        Parameters
        ----------
        deleteZerosRows: bool
            Boolean wheter to remove rows which have only zero entries.
            (e.g. reactions which never carry flux in all runs)
            Default: True
        &#34;&#34;&#34;
        self.csvs = {}
        exchange_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ExchangeData.csv&#39;
        else:
            filename = &#39;ExchangeData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ExchangeData.Elements.keys())
            exchange_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ExchangeData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ExchangeData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ExchangeData.Elements[i].values())
                valuerow2 = []
                for j in valuerow:
                    if pandas.isna(j):
                        valuerow2.append(0)
                    else:
                        valuerow2.append(j)
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow2):
                        row = [i]+valuerow2
                        exchange_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow2
                    exchange_data_csv += &#39;,&#39;.join(map(row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ExchangeData.csv&#39;] = exchange_data_csv

        general_info_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_GeneralInfo.csv&#39;
        else:
            filename = &#39;GeneralInfo.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.GeneralRunInfo.Elements.keys())
            general_info_csv += &#39;,&#39;.join([&#39;&#39;] +
                                         list(self.GeneralRunInfo.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.GeneralRunInfo.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.GeneralRunInfo.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        general_info_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    general_info_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;GeneralInfo.csv&#39;] = general_info_csv

        reaction_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ReactionData.csv&#39;
        else:
            filename = &#39;ReactionData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ReactionData.Elements.keys())
            reaction_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ReactionData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ReactionData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ReactionData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        reaction_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    reaction_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ReactionData.csv&#39;] = reaction_data_csv

        enzyme_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_EnzymeData.csv&#39;
        else:
            filename = &#39;EnzymeData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.EnzymeData.Elements.keys())
            enzyme_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.EnzymeData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.EnzymeData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.EnzymeData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        enzyme_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    enzyme_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;EnzymeData.csv&#39;] = enzyme_data_csv

        protein_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProteinData.csv&#39;
        else:
            filename = &#39;ProteinData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProteinData.Elements.keys())
            protein_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ProteinData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProteinData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProteinData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        protein_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    protein_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProteinData.csv&#39;] = protein_data_csv

        proto_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProtoProteinData.csv&#39;
        else:
            filename = &#39;ProtoProteinData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProtoProteinData.Elements.keys())
            proto_data_csv += &#39;,&#39;.join([&#39;&#39;] +
                                       list(self.ProtoProteinData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProtoProteinData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProtoProteinData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        proto_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    proto_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProtoData.csv&#39;] = proto_data_csv

        process_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProcessData.csv&#39;
        else:
            filename = &#39;ProcessData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProcessData.Elements.keys())
            process_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ProcessData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProcessData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProcessData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        process_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    process_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProcessData.csv&#39;] = process_data_csv

        metabolite_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_MetaboliteConstraintData.csv&#39;
        else:
            filename = &#39;MetaboliteConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.MetaboliteConstraintData.Elements.keys())
            metabolite_constraint_csv += &#39;,&#39;.join(
                [&#39;&#39;]+list(self.MetaboliteConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.MetaboliteConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.MetaboliteConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        metabolite_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    metabolite_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;MetaboliteConstraint.csv&#39;] = metabolite_constraint_csv

        density_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_DensityConstraintData.csv&#39;
        else:
            filename = &#39;DensityConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.DensityConstraintData.Elements.keys())
            density_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                               list(self.DensityConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.DensityConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.DensityConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        density_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    density_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;DensityConstraint.csv&#39;] = density_constraint_csv

        process_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProcessConstraintData.csv&#39;
        else:
            filename = &#39;ProcessConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProcessConstraintData.Elements.keys())
            process_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                               list(self.ProcessConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProcessConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProcessConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        process_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    process_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProcessConstraint.csv&#39;] = process_constraint_csv

        enzyme_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_EnzymeConstraintData.csv&#39;
        else:
            filename = &#39;EnzymeConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.EnzymeConstraintData.Elements.keys())
            enzyme_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                              list(self.EnzymeConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.EnzymeConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.EnzymeConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        enzyme_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    enzyme_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;EnzymeConstraint.csv&#39;] = enzyme_constraint_csv

    def getCSVFiles(self):
        return self.csvs

    def exportEscherMap(self, etype=&#39;fluxes&#39;):
        &#34;&#34;&#34;
        Exports input file for generation of Escher maps.
        https://escher.github.io
        If argument type is &#39;fluxes&#39; the method return an Eschermap for the
        visualisation of reaction-fluxes
        If argument type is &#39;investment&#39; the method return an Eschermap for the
        visualisation of the amount of amino-acids invested in enzyme machinery
        for reactions.
        Parameters
        ----------
        type: str (&#39;fluxes&#39; or &#39;investment&#39;)
        Default: &#39;fluxes&#39;
        &#34;&#34;&#34;
        if etype is &#39;fluxes&#39;:
            IDs = [id[2:] for id in list(self.uniqueReactionData.Elements.keys())]
            for run in self.uniqueReactionData.Elements[list(self.uniqueReactionData.Elements.keys())[0]]:
                Values = [rxn[run] for rxn in list(self.uniqueReactionData.Elements.values())]
                intermediateReactionFluxes = dict(zip(IDs, Values))
                ReactionFluxes = {id: val for id,
                                  val in intermediateReactionFluxes.items() if val != 0.}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Eschermap_fluxes_&#39;+run+&#39;.json&#39;
                else:
                    filename = &#39;RBA_Eschermap_fluxes_&#39;+run+&#39;.json&#39;
                self.eschermap = json.dumps(ReactionFluxes, indent=4)
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(json.dumps(ReactionFluxes, indent=4))
        if etype is &#39;investment&#39;:
            IDs = list(self.uniqueReactionData.Elements.keys())
            for run in self.uniqueReactionData.Elements[list(self.uniqueReactionData.Elements.keys())[0]]:
                Fluxes = [rxn[run] for rxn in list(self.uniqueReactionData.Elements.values())]
                Intermediate = zip(IDs, Fluxes)
                RxnsToTest = [i[0] for i in Intermediate if i[1] != 0.]
                Values = [determineInvestment(self, rxn, run) for rxn in RxnsToTest]
                ReactionInvestments = {id[2:]: val for id,
                                       val in dict(zip(RxnsToTest, Values)).items()}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Eschermap_investment_&#39;+run+&#39;.json&#39;
                else:
                    filename = &#39;RBA_Eschermap_investment_&#39;+run+&#39;.json&#39;
                self.eschermap = json.dumps(ReactionInvestments, indent=4)
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(json.dumps(ReactionInvestments, indent=4))

    def getEscherMap(self):
        return self.eschermap

    def exportProteoMap(self, etype=&#39;proto&#39;):
        &#34;&#34;&#34;
        Exports input file for the generation of Proteo maps from
        simulation data.
        https://www.proteomaps.net
        &#34;&#34;&#34;
        if etype == &#39;isoforms&#39;:
            IDs = list(self.ProteinData.Elements.keys())
            for run in self.ProteinData.Elements[list(self.ProteinData.Elements.keys())[0]]:
                Values = [protein[run] for protein in list(self.ProteinData.Elements.values())]
                intermediateProteinLevels = dict(zip(IDs, Values))
                ProteinLevels = {id: val for id,
                                 val in intermediateProteinLevels.items() if val != 0.}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                else:
                    filename = &#39;RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                self.proteomap = &#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l)
                                            for p, l in ProteinLevels.items()])
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(&#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l) for p, l in ProteinLevels.items()]))
        if etype == &#39;proto&#39;:
            IDs = list(self.ProtoProteinData.Elements.keys())
            for run in self.ProtoProteinData.Elements[list(self.ProtoProteinData.Elements.keys())[0]]:
                Values = [protein[run] for protein in list(self.ProtoProteinData.Elements.values())]
                intermediateProteinLevels = dict(zip(IDs, Values))
                ProteinLevels = {id: val for id,
                                 val in intermediateProteinLevels.items() if val != 0.}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                else:
                    filename = &#39;RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                self.proteomap = &#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l)
                                            for p, l in ProteinLevels.items()])
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(&#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l) for p, l in ProteinLevels.items()]))

    def getProteoMap(self):
        return self.proteomap


def htmlStyle(structOriginal):
    struct = copy.deepcopy(structOriginal)
    for i in list(struct.ReactionData.Elements.keys()):
        struct.ReactionData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ReactionData.Elements.pop(i)
    for i in list(struct.EnzymeData.Elements.keys()):
        struct.EnzymeData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.EnzymeData.Elements.pop(i)
    for i in list(struct.ProcessData.Elements.keys()):
        struct.ProcessData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProcessData.Elements.pop(i)
    for i in list(struct.ProteinData.Elements.keys()):
        struct.ProteinData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProteinData.Elements.pop(i)
    for i in list(struct.MetaboliteConstraintData.Elements.keys()):
        struct.MetaboliteConstraintData.Elements[&#39;ID_&#39; + i +
                                                 &#39;_Data&#39;] = struct.MetaboliteConstraintData.Elements.pop(i)
    for i in list(struct.DensityConstraintData.Elements.keys()):
        struct.DensityConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.DensityConstraintData.Elements.pop(i)
    for i in list(struct.EnzymeConstraintData.Elements.keys()):
        struct.EnzymeConstraintData.Elements[&#39;ID_&#39; + i +
                                             &#39;_Data&#39;] = struct.EnzymeConstraintData.Elements.pop(i)
    for i in list(struct.ProcessConstraintData.Elements.keys()):
        struct.ProcessConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.ProcessConstraintData.Elements.pop(i)
    Block = {&#39;RunInfo&#39;: struct.GeneralRunInfo.JSONize(),
             &#39;ReactionData&#39;: struct.ReactionData.JSONize(),
             &#39;ProteinData&#39;: struct.ProteinData.JSONize(),
             &#39;EnzymeData&#39;: struct.EnzymeData.JSONize(),
             &#39;ProcessData&#39;: struct.ProcessData.JSONize(),
             &#39;MetaboliteConstraintData&#39;: struct.MetaboliteConstraintData.JSONize(),
             &#39;DensityConstraintData&#39;: struct.DensityConstraintData.JSONize(),
             &#39;EnzymeConstraintData&#39;: struct.EnzymeConstraintData.JSONize(),
             &#39;ProcessConstraintData&#39;: struct.ProcessConstraintData.JSONize()}
    return({&#39;RBA_ModelData&#39;: {&#39;SimulationData&#39;: Block}})


def htmlStyleAddingCol(structOriginal):
    struct = copy.deepcopy(structOriginal)
    for i in list(struct.ReactionData.Elements.keys()):
        count = 0
        for j in list(struct.ReactionData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ReactionData.Elements[i][&#39;C&#39; +
                                                str(count)+&#39;___&#39;+j] = struct.ReactionData.Elements[i].pop(j)
        struct.ReactionData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ReactionData.Elements.pop(i)
    for i in list(struct.EnzymeData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeData.Elements[i][&#39;C&#39; +
                                              str(count)+&#39;___&#39;+j] = struct.EnzymeData.Elements[i].pop(j)
        struct.EnzymeData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.EnzymeData.Elements.pop(i)
    for i in list(struct.ProcessData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessData.Elements[i][&#39;C&#39; +
                                               str(count)+&#39;___&#39;+j] = struct.ProcessData.Elements[i].pop(j)
        struct.ProcessData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProcessData.Elements.pop(i)
    for i in list(struct.ProteinData.Elements.keys()):
        count = 0
        for j in list(struct.ProteinData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProteinData.Elements[i][&#39;C&#39; +
                                               str(count)+&#39;___&#39;+j] = struct.ProteinData.Elements[i].pop(j)
        struct.ProteinData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProteinData.Elements.pop(i)
    for i in list(struct.MetaboliteConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.MetaboliteConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.MetaboliteConstraintData.Elements[i][&#39;C&#39;+str(
                    count)+&#39;___&#39;+j] = struct.MetaboliteConstraintData.Elements[i].pop(j)
        struct.MetaboliteConstraintData.Elements[&#39;ID_&#39; + i +
                                                 &#39;_Data&#39;] = struct.MetaboliteConstraintData.Elements.pop(i)
    for i in list(struct.DensityConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.DensityConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.DensityConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)+&#39;___&#39;+j] = struct.DensityConstraintData.Elements[i].pop(j)
        struct.DensityConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.DensityConstraintData.Elements.pop(i)
    for i in list(struct.EnzymeConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeConstraintData.Elements[i][&#39;C&#39; +
                                                        str(count)+&#39;___&#39;+j] = struct.EnzymeConstraintData.Elements[i].pop(j)
        struct.EnzymeConstraintData.Elements[&#39;ID_&#39; + i +
                                             &#39;_Data&#39;] = struct.EnzymeConstraintData.Elements.pop(i)
    for i in list(struct.ProcessConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)+&#39;___&#39;+j] = struct.ProcessConstraintData.Elements[i].pop(j)
        struct.ProcessConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.ProcessConstraintData.Elements.pop(i)
    Block = {&#39;RunInfo&#39;: struct.GeneralRunInfo.JSONize(),
             &#39;ReactionData&#39;: struct.ReactionData.JSONize(),
             &#39;ProteinData&#39;: struct.ProteinData.JSONize(),
             &#39;EnzymeData&#39;: struct.EnzymeData.JSONize(),
             &#39;ProcessData&#39;: struct.ProcessData.JSONize(),
             &#39;MetaboliteConstraintData&#39;: struct.MetaboliteConstraintData.JSONize(),
             &#39;DensityConstraintData&#39;: struct.DensityConstraintData.JSONize(),
             &#39;EnzymeConstraintData&#39;: struct.EnzymeConstraintData.JSONize(),
             &#39;ProcessConstraintData&#39;: struct.ProcessConstraintData.JSONize()}
    return({&#39;RBA_ModelData&#39;: {&#39;SimulationData&#39;: Block}})


def htmlStyleReplacingCol(structOriginal):
    struct = copy.deepcopy(structOriginal)
    for i in list(struct.ReactionData.Elements.keys()):
        count = 0
        for j in list(struct.ReactionData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ReactionData.Elements[i][&#39;C&#39; +
                                                str(count)] = struct.ReactionData.Elements[i].pop(j)
        struct.ReactionData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ReactionData.Elements.pop(i)
    for i in list(struct.EnzymeData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeData.Elements[i][&#39;C&#39;+str(count)] = struct.EnzymeData.Elements[i].pop(j)
        struct.EnzymeData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.EnzymeData.Elements.pop(i)
    for i in list(struct.ProcessData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessData.Elements[i][&#39;C&#39; +
                                               str(count)] = struct.ProcessData.Elements[i].pop(j)
        struct.ProcessData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProcessData.Elements.pop(i)
    for i in list(struct.ProteinData.Elements.keys()):
        count = 0
        for j in list(struct.ProteinData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProteinData.Elements[i][&#39;C&#39; +
                                               str(count)] = struct.ProteinData.Elements[i].pop(j)
        struct.ProteinData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProteinData.Elements.pop(i)
    for i in list(struct.MetaboliteConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.MetaboliteConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.MetaboliteConstraintData.Elements[i][&#39;C&#39; +
                                                            str(count)] = struct.MetaboliteConstraintData.Elements[i].pop(j)
        struct.MetaboliteConstraintData.Elements[&#39;ID_&#39; + i +
                                                 &#39;_Data&#39;] = struct.MetaboliteConstraintData.Elements.pop(i)
    for i in list(struct.DensityConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.DensityConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.DensityConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)] = struct.DensityConstraintData.Elements[i].pop(j)
        struct.DensityConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.DensityConstraintData.Elements.pop(i)
    for i in list(struct.EnzymeConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeConstraintData.Elements[i][&#39;C&#39; +
                                                        str(count)] = struct.EnzymeConstraintData.Elements[i].pop(j)
        struct.EnzymeConstraintData.Elements[&#39;ID_&#39; + i +
                                             &#39;_Data&#39;] = struct.EnzymeConstraintData.Elements.pop(i)
    for i in list(struct.ProcessConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)] = struct.ProcessConstraintData.Elements[i].pop(j)
        struct.ProcessConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.ProcessConstraintData.Elements.pop(i)
    Block = {&#39;RunInfo&#39;: struct.GeneralRunInfo.JSONize(),
             &#39;ReactionData&#39;: struct.ReactionData.JSONize(),
             &#39;ProteinData&#39;: struct.ProteinData.JSONize(),
             &#39;EnzymeData&#39;: struct.EnzymeData.JSONize(),
             &#39;ProcessData&#39;: struct.ProcessData.JSONize(),
             &#39;MetaboliteConstraintData&#39;: struct.MetaboliteConstraintData.JSONize(),
             &#39;DensityConstraintData&#39;: struct.DensityConstraintData.JSONize(),
             &#39;EnzymeConstraintData&#39;: struct.EnzymeConstraintData.JSONize(),
             &#39;ProcessConstraintData&#39;: struct.ProcessConstraintData.JSONize()}
    return({&#39;RBA_ModelData&#39;: {&#39;SimulationData&#39;: Block}})


def determineInvestment(SimData, rxn, run):
    investment = 0
    isoReactions = SimData.StructuralInformation.ReactionInfo.Elements[rxn][&#39;Twins&#39;]+[rxn]
    enzymesToCheck = [SimData.StructuralInformation.ReactionInfo.Elements[r][&#39;Enzyme&#39;] for r in isoReactions if len(
        SimData.StructuralInformation.ReactionInfo.Elements[r][&#39;Enzyme&#39;]) &gt; 0]
    for enzy in enzymesToCheck:
        prots = SimData.StructuralInformation.EnzymeInfo.Elements[enzy][&#39;Subunits&#39;]
        enzymeCost = 0
        for pr in list(prots.items()):
            SF = int(pr[1])
            AAnum = SimData.StructuralInformation.ProteinInfo.Elements[pr[0]][&#39;AAnumber&#39;]
            if numpy.isnan(AAnum):
                continue
            enzymeCost += SF*int(AAnum)
        investment += enzymeCost*SimData.EnzymeData.Elements[enzy][run]
    return(investment)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="rbatools.rba_SimulationData.determineInvestment"><code class="name flex">
<span>def <span class="ident">determineInvestment</span></span>(<span>SimData, rxn, run)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def determineInvestment(SimData, rxn, run):
    investment = 0
    isoReactions = SimData.StructuralInformation.ReactionInfo.Elements[rxn][&#39;Twins&#39;]+[rxn]
    enzymesToCheck = [SimData.StructuralInformation.ReactionInfo.Elements[r][&#39;Enzyme&#39;] for r in isoReactions if len(
        SimData.StructuralInformation.ReactionInfo.Elements[r][&#39;Enzyme&#39;]) &gt; 0]
    for enzy in enzymesToCheck:
        prots = SimData.StructuralInformation.EnzymeInfo.Elements[enzy][&#39;Subunits&#39;]
        enzymeCost = 0
        for pr in list(prots.items()):
            SF = int(pr[1])
            AAnum = SimData.StructuralInformation.ProteinInfo.Elements[pr[0]][&#39;AAnumber&#39;]
            if numpy.isnan(AAnum):
                continue
            enzymeCost += SF*int(AAnum)
        investment += enzymeCost*SimData.EnzymeData.Elements[enzy][run]
    return(investment)</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.htmlStyle"><code class="name flex">
<span>def <span class="ident">htmlStyle</span></span>(<span>structOriginal)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def htmlStyle(structOriginal):
    struct = copy.deepcopy(structOriginal)
    for i in list(struct.ReactionData.Elements.keys()):
        struct.ReactionData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ReactionData.Elements.pop(i)
    for i in list(struct.EnzymeData.Elements.keys()):
        struct.EnzymeData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.EnzymeData.Elements.pop(i)
    for i in list(struct.ProcessData.Elements.keys()):
        struct.ProcessData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProcessData.Elements.pop(i)
    for i in list(struct.ProteinData.Elements.keys()):
        struct.ProteinData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProteinData.Elements.pop(i)
    for i in list(struct.MetaboliteConstraintData.Elements.keys()):
        struct.MetaboliteConstraintData.Elements[&#39;ID_&#39; + i +
                                                 &#39;_Data&#39;] = struct.MetaboliteConstraintData.Elements.pop(i)
    for i in list(struct.DensityConstraintData.Elements.keys()):
        struct.DensityConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.DensityConstraintData.Elements.pop(i)
    for i in list(struct.EnzymeConstraintData.Elements.keys()):
        struct.EnzymeConstraintData.Elements[&#39;ID_&#39; + i +
                                             &#39;_Data&#39;] = struct.EnzymeConstraintData.Elements.pop(i)
    for i in list(struct.ProcessConstraintData.Elements.keys()):
        struct.ProcessConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.ProcessConstraintData.Elements.pop(i)
    Block = {&#39;RunInfo&#39;: struct.GeneralRunInfo.JSONize(),
             &#39;ReactionData&#39;: struct.ReactionData.JSONize(),
             &#39;ProteinData&#39;: struct.ProteinData.JSONize(),
             &#39;EnzymeData&#39;: struct.EnzymeData.JSONize(),
             &#39;ProcessData&#39;: struct.ProcessData.JSONize(),
             &#39;MetaboliteConstraintData&#39;: struct.MetaboliteConstraintData.JSONize(),
             &#39;DensityConstraintData&#39;: struct.DensityConstraintData.JSONize(),
             &#39;EnzymeConstraintData&#39;: struct.EnzymeConstraintData.JSONize(),
             &#39;ProcessConstraintData&#39;: struct.ProcessConstraintData.JSONize()}
    return({&#39;RBA_ModelData&#39;: {&#39;SimulationData&#39;: Block}})</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.htmlStyleAddingCol"><code class="name flex">
<span>def <span class="ident">htmlStyleAddingCol</span></span>(<span>structOriginal)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def htmlStyleAddingCol(structOriginal):
    struct = copy.deepcopy(structOriginal)
    for i in list(struct.ReactionData.Elements.keys()):
        count = 0
        for j in list(struct.ReactionData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ReactionData.Elements[i][&#39;C&#39; +
                                                str(count)+&#39;___&#39;+j] = struct.ReactionData.Elements[i].pop(j)
        struct.ReactionData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ReactionData.Elements.pop(i)
    for i in list(struct.EnzymeData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeData.Elements[i][&#39;C&#39; +
                                              str(count)+&#39;___&#39;+j] = struct.EnzymeData.Elements[i].pop(j)
        struct.EnzymeData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.EnzymeData.Elements.pop(i)
    for i in list(struct.ProcessData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessData.Elements[i][&#39;C&#39; +
                                               str(count)+&#39;___&#39;+j] = struct.ProcessData.Elements[i].pop(j)
        struct.ProcessData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProcessData.Elements.pop(i)
    for i in list(struct.ProteinData.Elements.keys()):
        count = 0
        for j in list(struct.ProteinData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProteinData.Elements[i][&#39;C&#39; +
                                               str(count)+&#39;___&#39;+j] = struct.ProteinData.Elements[i].pop(j)
        struct.ProteinData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProteinData.Elements.pop(i)
    for i in list(struct.MetaboliteConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.MetaboliteConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.MetaboliteConstraintData.Elements[i][&#39;C&#39;+str(
                    count)+&#39;___&#39;+j] = struct.MetaboliteConstraintData.Elements[i].pop(j)
        struct.MetaboliteConstraintData.Elements[&#39;ID_&#39; + i +
                                                 &#39;_Data&#39;] = struct.MetaboliteConstraintData.Elements.pop(i)
    for i in list(struct.DensityConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.DensityConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.DensityConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)+&#39;___&#39;+j] = struct.DensityConstraintData.Elements[i].pop(j)
        struct.DensityConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.DensityConstraintData.Elements.pop(i)
    for i in list(struct.EnzymeConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeConstraintData.Elements[i][&#39;C&#39; +
                                                        str(count)+&#39;___&#39;+j] = struct.EnzymeConstraintData.Elements[i].pop(j)
        struct.EnzymeConstraintData.Elements[&#39;ID_&#39; + i +
                                             &#39;_Data&#39;] = struct.EnzymeConstraintData.Elements.pop(i)
    for i in list(struct.ProcessConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)+&#39;___&#39;+j] = struct.ProcessConstraintData.Elements[i].pop(j)
        struct.ProcessConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.ProcessConstraintData.Elements.pop(i)
    Block = {&#39;RunInfo&#39;: struct.GeneralRunInfo.JSONize(),
             &#39;ReactionData&#39;: struct.ReactionData.JSONize(),
             &#39;ProteinData&#39;: struct.ProteinData.JSONize(),
             &#39;EnzymeData&#39;: struct.EnzymeData.JSONize(),
             &#39;ProcessData&#39;: struct.ProcessData.JSONize(),
             &#39;MetaboliteConstraintData&#39;: struct.MetaboliteConstraintData.JSONize(),
             &#39;DensityConstraintData&#39;: struct.DensityConstraintData.JSONize(),
             &#39;EnzymeConstraintData&#39;: struct.EnzymeConstraintData.JSONize(),
             &#39;ProcessConstraintData&#39;: struct.ProcessConstraintData.JSONize()}
    return({&#39;RBA_ModelData&#39;: {&#39;SimulationData&#39;: Block}})</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.htmlStyleReplacingCol"><code class="name flex">
<span>def <span class="ident">htmlStyleReplacingCol</span></span>(<span>structOriginal)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def htmlStyleReplacingCol(structOriginal):
    struct = copy.deepcopy(structOriginal)
    for i in list(struct.ReactionData.Elements.keys()):
        count = 0
        for j in list(struct.ReactionData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ReactionData.Elements[i][&#39;C&#39; +
                                                str(count)] = struct.ReactionData.Elements[i].pop(j)
        struct.ReactionData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ReactionData.Elements.pop(i)
    for i in list(struct.EnzymeData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeData.Elements[i][&#39;C&#39;+str(count)] = struct.EnzymeData.Elements[i].pop(j)
        struct.EnzymeData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.EnzymeData.Elements.pop(i)
    for i in list(struct.ProcessData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessData.Elements[i][&#39;C&#39; +
                                               str(count)] = struct.ProcessData.Elements[i].pop(j)
        struct.ProcessData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProcessData.Elements.pop(i)
    for i in list(struct.ProteinData.Elements.keys()):
        count = 0
        for j in list(struct.ProteinData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProteinData.Elements[i][&#39;C&#39; +
                                               str(count)] = struct.ProteinData.Elements[i].pop(j)
        struct.ProteinData.Elements[&#39;ID_&#39; + i + &#39;_Data&#39;] = struct.ProteinData.Elements.pop(i)
    for i in list(struct.MetaboliteConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.MetaboliteConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.MetaboliteConstraintData.Elements[i][&#39;C&#39; +
                                                            str(count)] = struct.MetaboliteConstraintData.Elements[i].pop(j)
        struct.MetaboliteConstraintData.Elements[&#39;ID_&#39; + i +
                                                 &#39;_Data&#39;] = struct.MetaboliteConstraintData.Elements.pop(i)
    for i in list(struct.DensityConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.DensityConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.DensityConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)] = struct.DensityConstraintData.Elements[i].pop(j)
        struct.DensityConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.DensityConstraintData.Elements.pop(i)
    for i in list(struct.EnzymeConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.EnzymeConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.EnzymeConstraintData.Elements[i][&#39;C&#39; +
                                                        str(count)] = struct.EnzymeConstraintData.Elements[i].pop(j)
        struct.EnzymeConstraintData.Elements[&#39;ID_&#39; + i +
                                             &#39;_Data&#39;] = struct.EnzymeConstraintData.Elements.pop(i)
    for i in list(struct.ProcessConstraintData.Elements.keys()):
        count = 0
        for j in list(struct.ProcessConstraintData.Elements[i].keys()):
            if j is not &#39;correspondingElement&#39;:
                count += 1
                struct.ProcessConstraintData.Elements[i][&#39;C&#39; +
                                                         str(count)] = struct.ProcessConstraintData.Elements[i].pop(j)
        struct.ProcessConstraintData.Elements[&#39;ID_&#39; + i +
                                              &#39;_Data&#39;] = struct.ProcessConstraintData.Elements.pop(i)
    Block = {&#39;RunInfo&#39;: struct.GeneralRunInfo.JSONize(),
             &#39;ReactionData&#39;: struct.ReactionData.JSONize(),
             &#39;ProteinData&#39;: struct.ProteinData.JSONize(),
             &#39;EnzymeData&#39;: struct.EnzymeData.JSONize(),
             &#39;ProcessData&#39;: struct.ProcessData.JSONize(),
             &#39;MetaboliteConstraintData&#39;: struct.MetaboliteConstraintData.JSONize(),
             &#39;DensityConstraintData&#39;: struct.DensityConstraintData.JSONize(),
             &#39;EnzymeConstraintData&#39;: struct.EnzymeConstraintData.JSONize(),
             &#39;ProcessConstraintData&#39;: struct.ProcessConstraintData.JSONize()}
    return({&#39;RBA_ModelData&#39;: {&#39;SimulationData&#39;: Block}})</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData"><code class="flex name class">
<span>class <span class="ident">RBA_SimulationData</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class holding information on simulations with the model.
Attributes</p>
<hr>
<dl>
<dt>StructuralInformation : rbatools.rba_ModelStructure RBA_ModelStructure object.</dt>
<dt>Model description</dt>
<dt><strong><code>SessionName</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of simulation session</dd>
</dl>
<p>ProteinData : rbatools.data_block DataBlock object.
Simulated protein levels
ReactionData : rbatools.data_block DataBlock object.
Simulated reaction data
EnzymeData : rbatools.data_block DataBlock object.
Simulated enzyme data
ProcessData : rbatools.data_block DataBlock object.
Simulated process machinery data
MetaboliteConstraintData : rbatools.data_block DataBlock object.
Simulation information on mass-balance constraints
DensityConstraintData : rbatools.data_block DataBlock object.
Simulation information on compartment-density constraints
ProcessConstraintData : rbatools.data_block DataBlock object.
Simulation information on process-capacity constraints
EnzymeConstraintData : rbatools.data_block DataBlock object.
Simulation information on enzyme-efficiency constraints
Methods</p>
<hr>
<p><strong>init</strong>(StaticData)
Initiates Simulation data object
fromSimulationResults(Controller, session_name)
Imports data from rbatools.RBA_Controler object
fromJSON(inputString)
Imports data from JSON string object
toXML()
Exports xml-file
toJSON()
Returns simulation data as JSON string
exportSBtab()
Exports SBtab files
exportSBtab_OneFile()
Exports simulation data in one single sbtab file
exportCSV(deleteZerosRows=True)
Exports simulation data as csv files
exportEscherMap(type='fluxes')
Exports input file for generation of Escher maps.
exportProteoMap()
Exports input file for the generation of Proteo maps from
simulation data.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RBA_SimulationData(object):
    &#34;&#34;&#34;
    Class holding information on simulations with the model.
    Attributes
    ----------
    StructuralInformation : rbatools.rba_ModelStructure RBA_ModelStructure object.
         Model description
    SessionName : str
         Name of simulation session
    ProteinData : rbatools.data_block DataBlock object.
         Simulated protein levels
    ReactionData : rbatools.data_block DataBlock object.
         Simulated reaction data
    EnzymeData : rbatools.data_block DataBlock object.
         Simulated enzyme data
    ProcessData : rbatools.data_block DataBlock object.
         Simulated process machinery data
    MetaboliteConstraintData : rbatools.data_block DataBlock object.
         Simulation information on mass-balance constraints
    DensityConstraintData : rbatools.data_block DataBlock object.
         Simulation information on compartment-density constraints
    ProcessConstraintData : rbatools.data_block DataBlock object.
         Simulation information on process-capacity constraints
    EnzymeConstraintData : rbatools.data_block DataBlock object.
         Simulation information on enzyme-efficiency constraints
    Methods
    ----------
    __init__(StaticData)
        Initiates Simulation data object
    fromSimulationResults(Controller, session_name)
        Imports data from rbatools.RBA_Controler object
    fromJSON(inputString)
        Imports data from JSON string object
    toXML()
        Exports xml-file
    toJSON()
        Returns simulation data as JSON string
    exportSBtab()
        Exports SBtab files
    exportSBtab_OneFile()
        Exports simulation data in one single sbtab file
    exportCSV(deleteZerosRows=True)
        Exports simulation data as csv files
    exportEscherMap(type=&#39;fluxes&#39;)
        Exports input file for generation of Escher maps.
    exportProteoMap()
        Exports input file for the generation of Proteo maps from
        simulation data.
    &#34;&#34;&#34;

    def __init__(self, StaticData):
        &#34;&#34;&#34;
        Initiates Simulation data object
        Parameters
        ----------
        StaticData : rbatools.RBA_ModelStructure
        &#34;&#34;&#34;

        self.StructuralInformation = copy.deepcopy(StaticData)

        self.ProteinData = DataBlock()
        self.ProtoProteinData = DataBlock()
        self.ReactionData = DataBlock()
        self.ExchangeData = DataBlock()
        self.uniqueReactionData = DataBlock()
        self.EnzymeData = DataBlock()
        self.ProcessData = DataBlock()
        self.MetaboliteConstraintData = DataBlock()
        self.DensityConstraintData = DataBlock()
        self.EnzymeConstraintData = DataBlock()
        self.ProcessConstraintData = DataBlock()
        self.GeneralRunInfo = DataBlock()
        self.ObjectiveFunctionInfo = DataBlock()

        self.SessionName = &#39;&#39;

        self.ProteinData.fromDict({})
        self.ProtoProteinData.fromDict({})
        self.ReactionData.fromDict({})
        self.ExchangeData.fromDict({})
        self.uniqueReactionData.fromDict({})
        self.EnzymeData.fromDict({})
        self.ProcessData.fromDict({})
        self.MetaboliteConstraintData.fromDict({})
        self.DensityConstraintData.fromDict({})
        self.EnzymeConstraintData.fromDict({})
        self.ProcessConstraintData.fromDict({})
        self.GeneralRunInfo.fromDict({})
        self.ObjectiveFunctionInfo.fromDict({})

    def fromSimulationResults(self, Controller, session_name=&#39;&#39;):
        &#34;&#34;&#34;
        Imports data from rbatools.RBA_Controler object
        Parameters
        ----------
        Controller : rbatools.RBA_newControler
            Defines from which object to extract the data from
        session_name: str
            Defines the name of the session
            Is appended to the filenames generated by export methods.
        &#34;&#34;&#34;
        self.SessionName = session_name

        self.run_names = list(Controller.Results[&#39;ObjectiveValue&#39;])
        ObjDict = {}
        for run in list(Controller.Results[&#39;ObjectiveValue&#39;]):
            ObjDict.update({run: Controller.Results[&#39;ObjectiveValue&#39;].loc[&#39;ObjectiveValue&#39;, run]})

        SolutionType_Dict = {}
        for run in list(Controller.Results[&#39;SolutionType&#39;]):
            SolutionType_Dict.update(
                {run: Controller.Results[&#39;SolutionType&#39;].loc[&#39;SolutionType&#39;, run]})

        MuDict = {}
        for run in list(Controller.Results[&#39;Mu&#39;]):
            MuDict.update({run: Controller.Results[&#39;Mu&#39;].loc[&#39;Mu&#39;, run]})

        self.GeneralRunInfo.addEntries({&#39;ProblemType&#39;: SolutionType_Dict})
        self.GeneralRunInfo.addEntries({&#39;Mu&#39;: MuDict})
        self.GeneralRunInfo.addEntries({&#39;Obj_Val&#39;: ObjDict})

        for var in list(Controller.Results[&#39;ObjectiveFunction&#39;].index):
            if var not in self.ObjectiveFunctionInfo.Elements:
                self.ObjectiveFunctionInfo.Elements.update({var: {}})
            for run in list(Controller.Results[&#39;ObjectiveFunction&#39;]):
                self.ObjectiveFunctionInfo.Elements[var].update(
                    {run: Controller.Results[&#39;ObjectiveFunction&#39;].loc[var, run]})

        for exchange in list(Controller.Results[&#39;ExchangeFluxes&#39;].index):
            if exchange not in self.ExchangeData.Elements:
                self.ExchangeData.Elements.update({exchange: {}})
#            self.ExchangeData.Elements[exchange].update({&#39;ID&#39;: exchange})
            for run in list(Controller.Results[&#39;ExchangeFluxes&#39;]):
                self.ExchangeData.Elements[exchange].update(
                    {run: Controller.Results[&#39;ExchangeFluxes&#39;].loc[exchange, run]})

        for reaction in list(Controller.Results[&#39;Reactions&#39;].index):
            if reaction not in self.ReactionData.Elements:
                self.ReactionData.Elements.update({reaction: {}})
#            self.ReactionData.Elements[reaction].update({&#39;ID&#39;: reaction})
            for run in list(Controller.Results[&#39;Reactions&#39;]):
                self.ReactionData.Elements[reaction].update(
                    {run: Controller.Results[&#39;Reactions&#39;].loc[reaction, run]})

        for reaction in list(Controller.Results[&#39;uniqueReactions&#39;].index):
            if reaction not in self.uniqueReactionData.Elements:
                self.uniqueReactionData.Elements.update({reaction: {}})
#            self.uniqueReactionData.Elements[reaction].update({&#39;ID&#39;: reaction})
            for run in list(Controller.Results[&#39;uniqueReactions&#39;]):
                self.uniqueReactionData.Elements[reaction].update(
                    {run: Controller.Results[&#39;uniqueReactions&#39;].loc[reaction, run]})

        for enzyme in list(Controller.Results[&#39;Enzymes&#39;].index):
            if enzyme not in self.EnzymeData.Elements:
                self.EnzymeData.Elements.update({enzyme: {}})
#            self.EnzymeData.Elements[enzyme].update({&#39;ID&#39;: enzyme})
            for run in list(Controller.Results[&#39;Enzymes&#39;]):
                self.EnzymeData.Elements[enzyme].update(
                    {run: Controller.Results[&#39;Enzymes&#39;].loc[enzyme, run]})

        for process in list(Controller.Results[&#39;Processes&#39;].index):
            if process not in self.ProcessData.Elements:
                self.ProcessData.Elements.update({process: {}})
#            self.ProcessData.Elements[process].update({&#39;ID&#39;: process})
            for run in list(Controller.Results[&#39;Processes&#39;]):
                self.ProcessData.Elements[process].update(
                    {run: Controller.Results[&#39;Processes&#39;].loc[process, run]})

        for protein in list(Controller.Results[&#39;Proteins&#39;].index):
            if protein not in self.ProteinData.Elements:
                self.ProteinData.Elements.update({protein: {}})
#            self.ProteinData.Elements[protein].update({&#39;ID&#39;: protein})
            for run in list(Controller.Results[&#39;Proteins&#39;]):
                self.ProteinData.Elements[protein].update(
                    {run: Controller.Results[&#39;Proteins&#39;].loc[protein, run]})

        for protoprotein in list(Controller.Results[&#39;ProtoProteins&#39;].index):
            if protoprotein not in self.ProtoProteinData.Elements:
                self.ProtoProteinData.Elements.update({protoprotein: {}})
#            self.ProtoProteinData.Elements[protoprotein].update({&#39;ID&#39;: protoprotein})
            for run in list(Controller.Results[&#39;ProtoProteins&#39;]):
                self.ProtoProteinData.Elements[protoprotein].update(
                    {run: Controller.Results[&#39;ProtoProteins&#39;].loc[protoprotein, run]})

        for constr in list(Controller.Results[&#39;Constraints&#39;].index):
            if constr in list(self.StructuralInformation.MetaboliteConstraintsInfo.Elements.keys()):
                if constr not in self.MetaboliteConstraintData.Elements:
                    self.MetaboliteConstraintData.Elements.update({constr: {}})
#                self.MetaboliteConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.MetaboliteConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.DensityConstraintsInfo.Elements.keys()):
                if constr not in self.DensityConstraintData.Elements:
                    self.DensityConstraintData.Elements.update({constr: {}})
#                self.DensityConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.DensityConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.EnzymeConstraintsInfo.Elements.keys()):
                if constr not in self.EnzymeConstraintData.Elements:
                    self.EnzymeConstraintData.Elements.update({constr: {}})
#                self.EnzymeConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.EnzymeConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.ProcessConstraintsInfo.Elements.keys()):
                if constr not in self.ProcessConstraintData.Elements:
                    self.ProcessConstraintData.Elements.update({constr: {}})
#                self.ProcessConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.ProcessConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})

    def fromJSON(self, inputString):
        &#34;&#34;&#34;
        Imports data from JSON string object
        Parameters
        ----------
        inputString: json-string
        &#34;&#34;&#34;

        Block = json.loads(inputString)
        self.ReactionData = DataBlock()
        self.ProteinData = DataBlock()
        self.EnzymeData = DataBlock()
        self.ProcessData = DataBlock()
        self.MetaboliteConstraintData = DataBlock()
        self.DensityConstraintData = DataBlock()
        self.EnzymeConstraintData = DataBlock()
        self.ProcessConstraintData = DataBlock()
        self.ReactionData.fromDict(Block[&#39;ReactionData&#39;])
        self.ProteinData.fromDict(Block[&#39;ProteinData&#39;])
        self.EnzymeData.fromDict(Block[&#39;EnzymeData&#39;])
        self.ProcessData.fromDict(Block[&#39;ProcessData&#39;])
        self.MetaboliteConstraintData.fromDict(Block[&#39;MetaboliteConstraintData&#39;])
        self.DensityConstraintData.fromDict(Block[&#39;DensityConstraintData&#39;])
        self.EnzymeConstraintData.fromDict(Block[&#39;EnzymeConstraintData&#39;])
        self.ProcessConstraintData.fromDict(Block[&#39;ProcessConstraintData&#39;])

    def exportXML(self):
        &#34;&#34;&#34;
        Exports xml-file
        &#34;&#34;&#34;

        x = htmlStyle(self)
        root = ET.fromstring(jxmlease.emit_xml(x, encoding=&#39;utf-8&#39;))
        m = ET.tostring(root, &#39;utf-8&#39;)
        return(m)

    def exportSBtab(self, filename=None, add_links=False):
        &#34;&#34;&#34;
        Exports simulation data in one single sbtab file
        &#34;&#34;&#34;
        GeneralRunInfoTable = self.GeneralRunInfo.toSBtab(
            table_id=&#39;run_information&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Run information&#39;)
        GeneralRunInfoTable.filename = &#39;RunInfo.tsv&#39;
        GeneralRunInfoTable.change_attribute(
            &#39;Text&#39;, &#39;Growth rates mu and cellular objective values (by default: minimisation of total enzyme concentration).&#39;)
        # GeneralRunInfoTable.unset_attribute(&#39;Date&#39;)
        GeneralRunInfoTable.unset_attribute(&#39;SBtabVersion&#39;)

        ObjectiveFunctionDataTable = self.ObjectiveFunctionInfo.toSBtab(
            table_id=&#39;objective_coefficients&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Linear objective&#39;)
        ObjectiveFunctionDataTable.filename = &#39;ObjectiveFunctionData.tsv&#39;
        ObjectiveFunctionDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        ObjectiveFunctionDataTable.change_attribute(&#39;QuantityType&#39;, &#39;objective_coefficient&#39;)
        ObjectiveFunctionDataTable.change_attribute(
            &#39;Text&#39;, &#39;Coefficients in objective function (&lt;0 : maximisation , &gt;0 : minimisation)&#39;)
        # ObjectiveFunctionDataTable.unset_attribute(&#39;Date&#39;)
        ObjectiveFunctionDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ReactionDataTable = self.ReactionData.toSBtab(
            table_id=&#39;reaction_flux&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Reaction fluxes&#39;)
        ReactionDataTable.filename = &#39;ReactionData.tsv&#39;
        ReactionDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/(h*gDW)&#39;)
        ReactionDataTable.change_attribute(&#39;QuantityType&#39;, &#39;reaction_flux&#39;)
        ReactionDataTable.change_attribute(
            &#39;Text&#39;, &#39;Reaction fluxes obtained in the simulation runs (table columns).&#39;)
        # ReactionDataTable.unset_attribute(&#39;Date&#39;)
        ReactionDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        EnzymeDataTable = self.EnzymeData.toSBtab(
            table_id=&#39;enzyme_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Enzyme concentrations&#39;)
        EnzymeDataTable.filename = &#39;EnzymeData.tsv&#39;
        EnzymeDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
        EnzymeDataTable.change_attribute(&#39;QuantityType&#39;, &#39;enzyme_concentration&#39;)
        EnzymeDataTable.change_attribute(
            &#39;Text&#39;, &#39;Enzyme concentrations obtained in the simulation runs (table columns).&#39;)
        # EnzymeDataTable.unset_attribute(&#39;Date&#39;)
        EnzymeDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ProcessDataTable = self.ProcessData.toSBtab(
            table_id=&#39;machine_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Machine concentrations&#39;)
        ProcessDataTable.filename = &#39;ProcessData.tsv&#39;
        ProcessDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
        ProcessDataTable.change_attribute(&#39;QuantityType&#39;, &#39;machine_concentration&#39;)
        ProcessDataTable.change_attribute(
            &#39;Text&#39;, &#39;Macromolecular machine concentrations obtained in the simulation runs (table columns).&#39;)
        # ProcessDataTable.unset_attribute(&#39;Date&#39;)
        ProcessDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ProteinDataTable = self.ProteinData.toSBtab(
            table_id=&#39;protein_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Protein concentrations&#39;)
        ProteinDataTable.filename = &#39;ProteinData.tsv&#39;
        ProteinDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
        ProteinDataTable.change_attribute(&#39;QuantityType&#39;, &#39;protein_concentration&#39;)
        ProteinDataTable.change_attribute(
            &#39;Text&#39;, &#39;Protein concentrations obtained in the simulation runs (table columns).&#39;)
        # ProteinDataTable.unset_attribute(&#39;Date&#39;)
        ProteinDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        MetaboliteConstraintDataTable = self.MetaboliteConstraintData.toSBtab(
            table_id=&#39;metabolite_mass_balance_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Metabolite mass-balance dual values&#39;)
        MetaboliteConstraintDataTable.filename = &#39;MetaboliteConstraintData.tsv&#39;
        MetaboliteConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        MetaboliteConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        MetaboliteConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the metabolite mass-balance constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # MetaboliteConstraintDataTable.unset_attribute(&#39;Date&#39;)
        MetaboliteConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        DensityConstraintDataTable = self.DensityConstraintData.toSBtab(
            table_id=&#39;density_constraint_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Compartment density dual values&#39;)
        DensityConstraintDataTable.filename = &#39;DensityConstraintData.tsv&#39;
        DensityConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        DensityConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        DensityConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the density constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # DensityConstraintDataTable.unset_attribute(&#39;Date&#39;)
        DensityConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        EnzymeConstraintDataTable = self.EnzymeConstraintData.toSBtab(
            table_id=&#39;enzyme_capacity_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Enzyme capacity dual values&#39;)
        EnzymeConstraintDataTable.filename = &#39;EnzymeConstraintData.tsv&#39;
        EnzymeConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        EnzymeConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        EnzymeConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the enzyme-capacity constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # EnzymeConstraintDataTable.unset_attribute(&#39;Date&#39;)
        EnzymeConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        ProcessConstraintDataTable = self.ProcessConstraintData.toSBtab(
            table_id=&#39;machine_capacity_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Machine capacity dual values&#39;)
        ProcessConstraintDataTable.filename = &#39;ProcessConstraintData.tsv&#39;
        ProcessConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
        ProcessConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
        ProcessConstraintDataTable.change_attribute(
            &#39;Text&#39;, &#39;Shadow prices of the machine-capacity constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
        # ProcessConstraintDataTable.unset_attribute(&#39;Date&#39;)
        ProcessConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

        if filename is not None:
            filename_SBtab = filename
        else:
            filename_SBtab = &#39;RBA_results&#39;

        if add_links:
            ReactionDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Reaction/&#39;+entry+&#39;!)&#39;)
                                                                     for entry in list(ReactionDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            ProcessDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Process/&#39;+entry+&#39;!)&#39;)
                                                                    for entry in list(ProcessDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            EnzymeDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Enzyme/&#39;+entry+&#39;!)&#39;)
                                                                   for entry in list(EnzymeDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            ProteinDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Protein/&#39;+entry+&#39;!)&#39;)
                                                                    for entry in list(ProteinDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            MetaboliteConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Compound/&#39;+entry+&#39;!)&#39;) for entry in list(MetaboliteConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            DensityConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Compartment/&#39;+entry+&#39;!)&#39;) for entry in list(DensityConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            ProcessConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Process/&#39;+entry+&#39;!)&#39;) for entry in list(ProcessConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
            EnzymeConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
                &#39;(!&#39;+&#39;Enzyme/&#39;+entry+&#39;!)&#39;) for entry in list(EnzymeConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)

            filename_SBtab += &#39;_HTML&#39;

        else:
            ReactionDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ReactionDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            ProcessDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ProcessDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            EnzymeDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(EnzymeDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            ProteinDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ProteinDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            MetaboliteConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(MetaboliteConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            DensityConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(DensityConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            ProcessConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(ProcessConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
            EnzymeConstraintDataTable.add_column(
                column_list=[&#39;!ElementID&#39;]+list(EnzymeConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)

        ReactionDataTable.remove_column(position=2)
        ProcessDataTable.remove_column(position=2)
        EnzymeDataTable.remove_column(position=2)
        ProteinDataTable.remove_column(position=2)
        MetaboliteConstraintDataTable.remove_column(position=2)
        DensityConstraintDataTable.remove_column(position=2)
        ProcessConstraintDataTable.remove_column(position=2)
        EnzymeConstraintDataTable.remove_column(position=2)

        self.Out = SBtab.SBtabDocument(name=&#39;rbatools_SimulationData_withLinks&#39;,
                                       sbtab_init=None, filename=str(filename_SBtab+&#39;.tsv&#39;))
        self.Out.add_sbtab(GeneralRunInfoTable)
        self.Out.add_sbtab(ObjectiveFunctionDataTable)
        self.Out.add_sbtab(ReactionDataTable)
        self.Out.add_sbtab(EnzymeDataTable)
        self.Out.add_sbtab(ProcessDataTable)
        self.Out.add_sbtab(ProteinDataTable)
        self.Out.add_sbtab(MetaboliteConstraintDataTable)
        self.Out.add_sbtab(DensityConstraintDataTable)
        self.Out.add_sbtab(EnzymeConstraintDataTable)
        self.Out.add_sbtab(ProcessConstraintDataTable)

        self.Out.change_attribute(&#39;DocumentName&#39;, &#39;RBA data&#39;)
        self.Out.name = filename
        self.Out.change_attribute(&#39;DocumentType&#39;, &#39;rba-simulation-data&#39;)
        self.Out.write()

    def getSBtabDoc(self):
        return self.Out

    def exportJSON(self):
        &#34;&#34;&#34;
        Returns simulation data as JSON string
        Returns
        -------
        JSON string
        &#34;&#34;&#34;

        Block = {&#39;ReactionData&#39;: self.ReactionData.Elements,
                 &#39;ProteinData&#39;: self.ProteinData.Elements,
                 &#39;EnzymeData&#39;: self.EnzymeData.Elements,
                 &#39;ProcessData&#39;: self.ProcessData.Elements,
                 &#39;MetaboliteConstraintData&#39;: self.MetaboliteConstraintData.Elements,
                 &#39;DensityConstraintData&#39;: self.DensityConstraintData.Elements,
                 &#39;EnzymeConstraintData&#39;: self.EnzymeConstraintData.Elements,
                 &#39;ProcessConstraintData&#39;: self.ProcessConstraintData.Elements}
        return(json.dumps(Block))

    def exportCSV(self, deleteZerosRows=True):
        &#34;&#34;&#34;
        Exports simulation data as csv files
        Parameters
        ----------
        deleteZerosRows: bool
            Boolean wheter to remove rows which have only zero entries.
            (e.g. reactions which never carry flux in all runs)
            Default: True
        &#34;&#34;&#34;
        self.csvs = {}
        exchange_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ExchangeData.csv&#39;
        else:
            filename = &#39;ExchangeData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ExchangeData.Elements.keys())
            exchange_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ExchangeData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ExchangeData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ExchangeData.Elements[i].values())
                valuerow2 = []
                for j in valuerow:
                    if pandas.isna(j):
                        valuerow2.append(0)
                    else:
                        valuerow2.append(j)
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow2):
                        row = [i]+valuerow2
                        exchange_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow2
                    exchange_data_csv += &#39;,&#39;.join(map(row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ExchangeData.csv&#39;] = exchange_data_csv

        general_info_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_GeneralInfo.csv&#39;
        else:
            filename = &#39;GeneralInfo.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.GeneralRunInfo.Elements.keys())
            general_info_csv += &#39;,&#39;.join([&#39;&#39;] +
                                         list(self.GeneralRunInfo.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.GeneralRunInfo.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.GeneralRunInfo.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        general_info_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    general_info_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;GeneralInfo.csv&#39;] = general_info_csv

        reaction_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ReactionData.csv&#39;
        else:
            filename = &#39;ReactionData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ReactionData.Elements.keys())
            reaction_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ReactionData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ReactionData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ReactionData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        reaction_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    reaction_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ReactionData.csv&#39;] = reaction_data_csv

        enzyme_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_EnzymeData.csv&#39;
        else:
            filename = &#39;EnzymeData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.EnzymeData.Elements.keys())
            enzyme_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.EnzymeData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.EnzymeData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.EnzymeData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        enzyme_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    enzyme_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;EnzymeData.csv&#39;] = enzyme_data_csv

        protein_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProteinData.csv&#39;
        else:
            filename = &#39;ProteinData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProteinData.Elements.keys())
            protein_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ProteinData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProteinData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProteinData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        protein_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    protein_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProteinData.csv&#39;] = protein_data_csv

        proto_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProtoProteinData.csv&#39;
        else:
            filename = &#39;ProtoProteinData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProtoProteinData.Elements.keys())
            proto_data_csv += &#39;,&#39;.join([&#39;&#39;] +
                                       list(self.ProtoProteinData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProtoProteinData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProtoProteinData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        proto_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    proto_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProtoData.csv&#39;] = proto_data_csv

        process_data_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProcessData.csv&#39;
        else:
            filename = &#39;ProcessData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProcessData.Elements.keys())
            process_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ProcessData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProcessData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProcessData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        process_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    process_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProcessData.csv&#39;] = process_data_csv

        metabolite_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_MetaboliteConstraintData.csv&#39;
        else:
            filename = &#39;MetaboliteConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.MetaboliteConstraintData.Elements.keys())
            metabolite_constraint_csv += &#39;,&#39;.join(
                [&#39;&#39;]+list(self.MetaboliteConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.MetaboliteConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.MetaboliteConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        metabolite_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    metabolite_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;MetaboliteConstraint.csv&#39;] = metabolite_constraint_csv

        density_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_DensityConstraintData.csv&#39;
        else:
            filename = &#39;DensityConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.DensityConstraintData.Elements.keys())
            density_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                               list(self.DensityConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.DensityConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.DensityConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        density_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    density_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;DensityConstraint.csv&#39;] = density_constraint_csv

        process_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_ProcessConstraintData.csv&#39;
        else:
            filename = &#39;ProcessConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.ProcessConstraintData.Elements.keys())
            process_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                               list(self.ProcessConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.ProcessConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.ProcessConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        process_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    process_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;ProcessConstraint.csv&#39;] = process_constraint_csv

        enzyme_constraint_csv = &#39;&#39;
        if len(self.SessionName) &gt; 0:
            filename = self.SessionName+&#39;_EnzymeConstraintData.csv&#39;
        else:
            filename = &#39;EnzymeConstraintData.csv&#39;
        with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
            wr = csv.writer(fp, dialect=&#39;excel&#39;)
            IDs = list(self.EnzymeConstraintData.Elements.keys())
            enzyme_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                              list(self.EnzymeConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
            wr.writerow([None]+list(self.EnzymeConstraintData.Elements[IDs[0]].keys()))
            for i in list(IDs):
                valuerow = list(self.EnzymeConstraintData.Elements[i].values())
                if deleteZerosRows:
                    if not all(v == 0 for v in valuerow):
                        row = [i]+valuerow
                        enzyme_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                        wr.writerow(row)
                else:
                    row = [i]+valuerow
                    enzyme_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
        fp.close()
        self.csvs[&#39;EnzymeConstraint.csv&#39;] = enzyme_constraint_csv

    def getCSVFiles(self):
        return self.csvs

    def exportEscherMap(self, etype=&#39;fluxes&#39;):
        &#34;&#34;&#34;
        Exports input file for generation of Escher maps.
        https://escher.github.io
        If argument type is &#39;fluxes&#39; the method return an Eschermap for the
        visualisation of reaction-fluxes
        If argument type is &#39;investment&#39; the method return an Eschermap for the
        visualisation of the amount of amino-acids invested in enzyme machinery
        for reactions.
        Parameters
        ----------
        type: str (&#39;fluxes&#39; or &#39;investment&#39;)
        Default: &#39;fluxes&#39;
        &#34;&#34;&#34;
        if etype is &#39;fluxes&#39;:
            IDs = [id[2:] for id in list(self.uniqueReactionData.Elements.keys())]
            for run in self.uniqueReactionData.Elements[list(self.uniqueReactionData.Elements.keys())[0]]:
                Values = [rxn[run] for rxn in list(self.uniqueReactionData.Elements.values())]
                intermediateReactionFluxes = dict(zip(IDs, Values))
                ReactionFluxes = {id: val for id,
                                  val in intermediateReactionFluxes.items() if val != 0.}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Eschermap_fluxes_&#39;+run+&#39;.json&#39;
                else:
                    filename = &#39;RBA_Eschermap_fluxes_&#39;+run+&#39;.json&#39;
                self.eschermap = json.dumps(ReactionFluxes, indent=4)
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(json.dumps(ReactionFluxes, indent=4))
        if etype is &#39;investment&#39;:
            IDs = list(self.uniqueReactionData.Elements.keys())
            for run in self.uniqueReactionData.Elements[list(self.uniqueReactionData.Elements.keys())[0]]:
                Fluxes = [rxn[run] for rxn in list(self.uniqueReactionData.Elements.values())]
                Intermediate = zip(IDs, Fluxes)
                RxnsToTest = [i[0] for i in Intermediate if i[1] != 0.]
                Values = [determineInvestment(self, rxn, run) for rxn in RxnsToTest]
                ReactionInvestments = {id[2:]: val for id,
                                       val in dict(zip(RxnsToTest, Values)).items()}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Eschermap_investment_&#39;+run+&#39;.json&#39;
                else:
                    filename = &#39;RBA_Eschermap_investment_&#39;+run+&#39;.json&#39;
                self.eschermap = json.dumps(ReactionInvestments, indent=4)
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(json.dumps(ReactionInvestments, indent=4))

    def getEscherMap(self):
        return self.eschermap

    def exportProteoMap(self, etype=&#39;proto&#39;):
        &#34;&#34;&#34;
        Exports input file for the generation of Proteo maps from
        simulation data.
        https://www.proteomaps.net
        &#34;&#34;&#34;
        if etype == &#39;isoforms&#39;:
            IDs = list(self.ProteinData.Elements.keys())
            for run in self.ProteinData.Elements[list(self.ProteinData.Elements.keys())[0]]:
                Values = [protein[run] for protein in list(self.ProteinData.Elements.values())]
                intermediateProteinLevels = dict(zip(IDs, Values))
                ProteinLevels = {id: val for id,
                                 val in intermediateProteinLevels.items() if val != 0.}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                else:
                    filename = &#39;RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                self.proteomap = &#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l)
                                            for p, l in ProteinLevels.items()])
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(&#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l) for p, l in ProteinLevels.items()]))
        if etype == &#39;proto&#39;:
            IDs = list(self.ProtoProteinData.Elements.keys())
            for run in self.ProtoProteinData.Elements[list(self.ProtoProteinData.Elements.keys())[0]]:
                Values = [protein[run] for protein in list(self.ProtoProteinData.Elements.values())]
                intermediateProteinLevels = dict(zip(IDs, Values))
                ProteinLevels = {id: val for id,
                                 val in intermediateProteinLevels.items() if val != 0.}
                if len(self.SessionName) &gt; 0:
                    filename = self.SessionName+&#39;_RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                else:
                    filename = &#39;RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
                self.proteomap = &#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l)
                                            for p, l in ProteinLevels.items()])
                with open(filename, &#39;w&#39;) as fout:
                    fout.write(&#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l) for p, l in ProteinLevels.items()]))

    def getProteoMap(self):
        return self.proteomap</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, StaticData)</span>
</code></dt>
<dd>
<section class="desc"><p>Initiates Simulation data object
Parameters</p>
<hr>
<dl>
<dt><strong><code>StaticData</code></strong> :&ensp;<code>rbatools.RBA_ModelStructure</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, StaticData):
    &#34;&#34;&#34;
    Initiates Simulation data object
    Parameters
    ----------
    StaticData : rbatools.RBA_ModelStructure
    &#34;&#34;&#34;

    self.StructuralInformation = copy.deepcopy(StaticData)

    self.ProteinData = DataBlock()
    self.ProtoProteinData = DataBlock()
    self.ReactionData = DataBlock()
    self.ExchangeData = DataBlock()
    self.uniqueReactionData = DataBlock()
    self.EnzymeData = DataBlock()
    self.ProcessData = DataBlock()
    self.MetaboliteConstraintData = DataBlock()
    self.DensityConstraintData = DataBlock()
    self.EnzymeConstraintData = DataBlock()
    self.ProcessConstraintData = DataBlock()
    self.GeneralRunInfo = DataBlock()
    self.ObjectiveFunctionInfo = DataBlock()

    self.SessionName = &#39;&#39;

    self.ProteinData.fromDict({})
    self.ProtoProteinData.fromDict({})
    self.ReactionData.fromDict({})
    self.ExchangeData.fromDict({})
    self.uniqueReactionData.fromDict({})
    self.EnzymeData.fromDict({})
    self.ProcessData.fromDict({})
    self.MetaboliteConstraintData.fromDict({})
    self.DensityConstraintData.fromDict({})
    self.EnzymeConstraintData.fromDict({})
    self.ProcessConstraintData.fromDict({})
    self.GeneralRunInfo.fromDict({})
    self.ObjectiveFunctionInfo.fromDict({})</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.exportCSV"><code class="name flex">
<span>def <span class="ident">exportCSV</span></span>(<span>self, deleteZerosRows=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Exports simulation data as csv files
Parameters</p>
<hr>
<dl>
<dt><strong><code>deleteZerosRows</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean wheter to remove rows which have only zero entries.
(e.g. reactions which never carry flux in all runs)
Default: True</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exportCSV(self, deleteZerosRows=True):
    &#34;&#34;&#34;
    Exports simulation data as csv files
    Parameters
    ----------
    deleteZerosRows: bool
        Boolean wheter to remove rows which have only zero entries.
        (e.g. reactions which never carry flux in all runs)
        Default: True
    &#34;&#34;&#34;
    self.csvs = {}
    exchange_data_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_ExchangeData.csv&#39;
    else:
        filename = &#39;ExchangeData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.ExchangeData.Elements.keys())
        exchange_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ExchangeData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.ExchangeData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.ExchangeData.Elements[i].values())
            valuerow2 = []
            for j in valuerow:
                if pandas.isna(j):
                    valuerow2.append(0)
                else:
                    valuerow2.append(j)
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow2):
                    row = [i]+valuerow2
                    exchange_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow2
                exchange_data_csv += &#39;,&#39;.join(map(row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;ExchangeData.csv&#39;] = exchange_data_csv

    general_info_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_GeneralInfo.csv&#39;
    else:
        filename = &#39;GeneralInfo.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.GeneralRunInfo.Elements.keys())
        general_info_csv += &#39;,&#39;.join([&#39;&#39;] +
                                     list(self.GeneralRunInfo.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.GeneralRunInfo.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.GeneralRunInfo.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    general_info_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                general_info_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;GeneralInfo.csv&#39;] = general_info_csv

    reaction_data_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_ReactionData.csv&#39;
    else:
        filename = &#39;ReactionData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.ReactionData.Elements.keys())
        reaction_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ReactionData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.ReactionData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.ReactionData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    reaction_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                reaction_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;ReactionData.csv&#39;] = reaction_data_csv

    enzyme_data_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_EnzymeData.csv&#39;
    else:
        filename = &#39;EnzymeData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.EnzymeData.Elements.keys())
        enzyme_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.EnzymeData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.EnzymeData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.EnzymeData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    enzyme_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                enzyme_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;EnzymeData.csv&#39;] = enzyme_data_csv

    protein_data_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_ProteinData.csv&#39;
    else:
        filename = &#39;ProteinData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.ProteinData.Elements.keys())
        protein_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ProteinData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.ProteinData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.ProteinData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    protein_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                protein_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;ProteinData.csv&#39;] = protein_data_csv

    proto_data_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_ProtoProteinData.csv&#39;
    else:
        filename = &#39;ProtoProteinData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.ProtoProteinData.Elements.keys())
        proto_data_csv += &#39;,&#39;.join([&#39;&#39;] +
                                   list(self.ProtoProteinData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.ProtoProteinData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.ProtoProteinData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    proto_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                proto_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;ProtoData.csv&#39;] = proto_data_csv

    process_data_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_ProcessData.csv&#39;
    else:
        filename = &#39;ProcessData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.ProcessData.Elements.keys())
        process_data_csv += &#39;,&#39;.join([&#39;&#39;]+list(self.ProcessData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.ProcessData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.ProcessData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    process_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                process_data_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;ProcessData.csv&#39;] = process_data_csv

    metabolite_constraint_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_MetaboliteConstraintData.csv&#39;
    else:
        filename = &#39;MetaboliteConstraintData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.MetaboliteConstraintData.Elements.keys())
        metabolite_constraint_csv += &#39;,&#39;.join(
            [&#39;&#39;]+list(self.MetaboliteConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.MetaboliteConstraintData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.MetaboliteConstraintData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    metabolite_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                metabolite_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;MetaboliteConstraint.csv&#39;] = metabolite_constraint_csv

    density_constraint_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_DensityConstraintData.csv&#39;
    else:
        filename = &#39;DensityConstraintData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.DensityConstraintData.Elements.keys())
        density_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                           list(self.DensityConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.DensityConstraintData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.DensityConstraintData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    density_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                density_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;DensityConstraint.csv&#39;] = density_constraint_csv

    process_constraint_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_ProcessConstraintData.csv&#39;
    else:
        filename = &#39;ProcessConstraintData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.ProcessConstraintData.Elements.keys())
        process_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                           list(self.ProcessConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.ProcessConstraintData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.ProcessConstraintData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    process_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                process_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;ProcessConstraint.csv&#39;] = process_constraint_csv

    enzyme_constraint_csv = &#39;&#39;
    if len(self.SessionName) &gt; 0:
        filename = self.SessionName+&#39;_EnzymeConstraintData.csv&#39;
    else:
        filename = &#39;EnzymeConstraintData.csv&#39;
    with open(filename, &#34;w&#34;, newline=&#39;&#39;) as fp:
        wr = csv.writer(fp, dialect=&#39;excel&#39;)
        IDs = list(self.EnzymeConstraintData.Elements.keys())
        enzyme_constraint_csv += &#39;,&#39;.join([&#39;&#39;] +
                                          list(self.EnzymeConstraintData.Elements[IDs[0]].keys()))+&#39;\n&#39;
        wr.writerow([None]+list(self.EnzymeConstraintData.Elements[IDs[0]].keys()))
        for i in list(IDs):
            valuerow = list(self.EnzymeConstraintData.Elements[i].values())
            if deleteZerosRows:
                if not all(v == 0 for v in valuerow):
                    row = [i]+valuerow
                    enzyme_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                    wr.writerow(row)
            else:
                row = [i]+valuerow
                enzyme_constraint_csv += &#39;,&#39;.join(map(str, row))+&#39;\n&#39;
                wr.writerow(row)
    fp.close()
    self.csvs[&#39;EnzymeConstraint.csv&#39;] = enzyme_constraint_csv</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.exportEscherMap"><code class="name flex">
<span>def <span class="ident">exportEscherMap</span></span>(<span>self, etype=&#39;fluxes&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Exports input file for generation of Escher maps.
<a href="https://escher.github.io">https://escher.github.io</a>
If argument type is 'fluxes' the method return an Eschermap for the
visualisation of reaction-fluxes
If argument type is 'investment' the method return an Eschermap for the
visualisation of the amount of amino-acids invested in enzyme machinery
for reactions.
Parameters</p>
<hr>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code> (<code>'fluxes'</code> or <code>'investment'</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>Default</code></strong> :&ensp;<code>'fluxes'</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exportEscherMap(self, etype=&#39;fluxes&#39;):
    &#34;&#34;&#34;
    Exports input file for generation of Escher maps.
    https://escher.github.io
    If argument type is &#39;fluxes&#39; the method return an Eschermap for the
    visualisation of reaction-fluxes
    If argument type is &#39;investment&#39; the method return an Eschermap for the
    visualisation of the amount of amino-acids invested in enzyme machinery
    for reactions.
    Parameters
    ----------
    type: str (&#39;fluxes&#39; or &#39;investment&#39;)
    Default: &#39;fluxes&#39;
    &#34;&#34;&#34;
    if etype is &#39;fluxes&#39;:
        IDs = [id[2:] for id in list(self.uniqueReactionData.Elements.keys())]
        for run in self.uniqueReactionData.Elements[list(self.uniqueReactionData.Elements.keys())[0]]:
            Values = [rxn[run] for rxn in list(self.uniqueReactionData.Elements.values())]
            intermediateReactionFluxes = dict(zip(IDs, Values))
            ReactionFluxes = {id: val for id,
                              val in intermediateReactionFluxes.items() if val != 0.}
            if len(self.SessionName) &gt; 0:
                filename = self.SessionName+&#39;_RBA_Eschermap_fluxes_&#39;+run+&#39;.json&#39;
            else:
                filename = &#39;RBA_Eschermap_fluxes_&#39;+run+&#39;.json&#39;
            self.eschermap = json.dumps(ReactionFluxes, indent=4)
            with open(filename, &#39;w&#39;) as fout:
                fout.write(json.dumps(ReactionFluxes, indent=4))
    if etype is &#39;investment&#39;:
        IDs = list(self.uniqueReactionData.Elements.keys())
        for run in self.uniqueReactionData.Elements[list(self.uniqueReactionData.Elements.keys())[0]]:
            Fluxes = [rxn[run] for rxn in list(self.uniqueReactionData.Elements.values())]
            Intermediate = zip(IDs, Fluxes)
            RxnsToTest = [i[0] for i in Intermediate if i[1] != 0.]
            Values = [determineInvestment(self, rxn, run) for rxn in RxnsToTest]
            ReactionInvestments = {id[2:]: val for id,
                                   val in dict(zip(RxnsToTest, Values)).items()}
            if len(self.SessionName) &gt; 0:
                filename = self.SessionName+&#39;_RBA_Eschermap_investment_&#39;+run+&#39;.json&#39;
            else:
                filename = &#39;RBA_Eschermap_investment_&#39;+run+&#39;.json&#39;
            self.eschermap = json.dumps(ReactionInvestments, indent=4)
            with open(filename, &#39;w&#39;) as fout:
                fout.write(json.dumps(ReactionInvestments, indent=4))</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.exportJSON"><code class="name flex">
<span>def <span class="ident">exportJSON</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns simulation data as JSON string
Returns</p>
<hr>
<p>JSON string</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exportJSON(self):
    &#34;&#34;&#34;
    Returns simulation data as JSON string
    Returns
    -------
    JSON string
    &#34;&#34;&#34;

    Block = {&#39;ReactionData&#39;: self.ReactionData.Elements,
             &#39;ProteinData&#39;: self.ProteinData.Elements,
             &#39;EnzymeData&#39;: self.EnzymeData.Elements,
             &#39;ProcessData&#39;: self.ProcessData.Elements,
             &#39;MetaboliteConstraintData&#39;: self.MetaboliteConstraintData.Elements,
             &#39;DensityConstraintData&#39;: self.DensityConstraintData.Elements,
             &#39;EnzymeConstraintData&#39;: self.EnzymeConstraintData.Elements,
             &#39;ProcessConstraintData&#39;: self.ProcessConstraintData.Elements}
    return(json.dumps(Block))</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.exportProteoMap"><code class="name flex">
<span>def <span class="ident">exportProteoMap</span></span>(<span>self, etype=&#39;proto&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Exports input file for the generation of Proteo maps from
simulation data.
<a href="https://www.proteomaps.net">https://www.proteomaps.net</a></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exportProteoMap(self, etype=&#39;proto&#39;):
    &#34;&#34;&#34;
    Exports input file for the generation of Proteo maps from
    simulation data.
    https://www.proteomaps.net
    &#34;&#34;&#34;
    if etype == &#39;isoforms&#39;:
        IDs = list(self.ProteinData.Elements.keys())
        for run in self.ProteinData.Elements[list(self.ProteinData.Elements.keys())[0]]:
            Values = [protein[run] for protein in list(self.ProteinData.Elements.values())]
            intermediateProteinLevels = dict(zip(IDs, Values))
            ProteinLevels = {id: val for id,
                             val in intermediateProteinLevels.items() if val != 0.}
            if len(self.SessionName) &gt; 0:
                filename = self.SessionName+&#39;_RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
            else:
                filename = &#39;RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
            self.proteomap = &#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l)
                                        for p, l in ProteinLevels.items()])
            with open(filename, &#39;w&#39;) as fout:
                fout.write(&#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l) for p, l in ProteinLevels.items()]))
    if etype == &#39;proto&#39;:
        IDs = list(self.ProtoProteinData.Elements.keys())
        for run in self.ProtoProteinData.Elements[list(self.ProtoProteinData.Elements.keys())[0]]:
            Values = [protein[run] for protein in list(self.ProtoProteinData.Elements.values())]
            intermediateProteinLevels = dict(zip(IDs, Values))
            ProteinLevels = {id: val for id,
                             val in intermediateProteinLevels.items() if val != 0.}
            if len(self.SessionName) &gt; 0:
                filename = self.SessionName+&#39;_RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
            else:
                filename = &#39;RBA_Proteomap_&#39;+run+&#39;.tsv&#39;
            self.proteomap = &#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l)
                                        for p, l in ProteinLevels.items()])
            with open(filename, &#39;w&#39;) as fout:
                fout.write(&#39;\n&#39;.join([&#39;{}\t{}&#39;.format(p, l) for p, l in ProteinLevels.items()]))</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.exportSBtab"><code class="name flex">
<span>def <span class="ident">exportSBtab</span></span>(<span>self, filename=None, add_links=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Exports simulation data in one single sbtab file</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exportSBtab(self, filename=None, add_links=False):
    &#34;&#34;&#34;
    Exports simulation data in one single sbtab file
    &#34;&#34;&#34;
    GeneralRunInfoTable = self.GeneralRunInfo.toSBtab(
        table_id=&#39;run_information&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Run information&#39;)
    GeneralRunInfoTable.filename = &#39;RunInfo.tsv&#39;
    GeneralRunInfoTable.change_attribute(
        &#39;Text&#39;, &#39;Growth rates mu and cellular objective values (by default: minimisation of total enzyme concentration).&#39;)
    # GeneralRunInfoTable.unset_attribute(&#39;Date&#39;)
    GeneralRunInfoTable.unset_attribute(&#39;SBtabVersion&#39;)

    ObjectiveFunctionDataTable = self.ObjectiveFunctionInfo.toSBtab(
        table_id=&#39;objective_coefficients&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Linear objective&#39;)
    ObjectiveFunctionDataTable.filename = &#39;ObjectiveFunctionData.tsv&#39;
    ObjectiveFunctionDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
    ObjectiveFunctionDataTable.change_attribute(&#39;QuantityType&#39;, &#39;objective_coefficient&#39;)
    ObjectiveFunctionDataTable.change_attribute(
        &#39;Text&#39;, &#39;Coefficients in objective function (&lt;0 : maximisation , &gt;0 : minimisation)&#39;)
    # ObjectiveFunctionDataTable.unset_attribute(&#39;Date&#39;)
    ObjectiveFunctionDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    ReactionDataTable = self.ReactionData.toSBtab(
        table_id=&#39;reaction_flux&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Reaction fluxes&#39;)
    ReactionDataTable.filename = &#39;ReactionData.tsv&#39;
    ReactionDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/(h*gDW)&#39;)
    ReactionDataTable.change_attribute(&#39;QuantityType&#39;, &#39;reaction_flux&#39;)
    ReactionDataTable.change_attribute(
        &#39;Text&#39;, &#39;Reaction fluxes obtained in the simulation runs (table columns).&#39;)
    # ReactionDataTable.unset_attribute(&#39;Date&#39;)
    ReactionDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    EnzymeDataTable = self.EnzymeData.toSBtab(
        table_id=&#39;enzyme_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Enzyme concentrations&#39;)
    EnzymeDataTable.filename = &#39;EnzymeData.tsv&#39;
    EnzymeDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
    EnzymeDataTable.change_attribute(&#39;QuantityType&#39;, &#39;enzyme_concentration&#39;)
    EnzymeDataTable.change_attribute(
        &#39;Text&#39;, &#39;Enzyme concentrations obtained in the simulation runs (table columns).&#39;)
    # EnzymeDataTable.unset_attribute(&#39;Date&#39;)
    EnzymeDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    ProcessDataTable = self.ProcessData.toSBtab(
        table_id=&#39;machine_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Machine concentrations&#39;)
    ProcessDataTable.filename = &#39;ProcessData.tsv&#39;
    ProcessDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
    ProcessDataTable.change_attribute(&#39;QuantityType&#39;, &#39;machine_concentration&#39;)
    ProcessDataTable.change_attribute(
        &#39;Text&#39;, &#39;Macromolecular machine concentrations obtained in the simulation runs (table columns).&#39;)
    # ProcessDataTable.unset_attribute(&#39;Date&#39;)
    ProcessDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    ProteinDataTable = self.ProteinData.toSBtab(
        table_id=&#39;protein_concentration&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Protein concentrations&#39;)
    ProteinDataTable.filename = &#39;ProteinData.tsv&#39;
    ProteinDataTable.change_attribute(&#39;Unit&#39;, &#39;mmol/gDW&#39;)
    ProteinDataTable.change_attribute(&#39;QuantityType&#39;, &#39;protein_concentration&#39;)
    ProteinDataTable.change_attribute(
        &#39;Text&#39;, &#39;Protein concentrations obtained in the simulation runs (table columns).&#39;)
    # ProteinDataTable.unset_attribute(&#39;Date&#39;)
    ProteinDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    MetaboliteConstraintDataTable = self.MetaboliteConstraintData.toSBtab(
        table_id=&#39;metabolite_mass_balance_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Metabolite mass-balance dual values&#39;)
    MetaboliteConstraintDataTable.filename = &#39;MetaboliteConstraintData.tsv&#39;
    MetaboliteConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
    MetaboliteConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
    MetaboliteConstraintDataTable.change_attribute(
        &#39;Text&#39;, &#39;Shadow prices of the metabolite mass-balance constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
    # MetaboliteConstraintDataTable.unset_attribute(&#39;Date&#39;)
    MetaboliteConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    DensityConstraintDataTable = self.DensityConstraintData.toSBtab(
        table_id=&#39;density_constraint_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Compartment density dual values&#39;)
    DensityConstraintDataTable.filename = &#39;DensityConstraintData.tsv&#39;
    DensityConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
    DensityConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
    DensityConstraintDataTable.change_attribute(
        &#39;Text&#39;, &#39;Shadow prices of the density constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
    # DensityConstraintDataTable.unset_attribute(&#39;Date&#39;)
    DensityConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    EnzymeConstraintDataTable = self.EnzymeConstraintData.toSBtab(
        table_id=&#39;enzyme_capacity_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Enzyme capacity dual values&#39;)
    EnzymeConstraintDataTable.filename = &#39;EnzymeConstraintData.tsv&#39;
    EnzymeConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
    EnzymeConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
    EnzymeConstraintDataTable.change_attribute(
        &#39;Text&#39;, &#39;Shadow prices of the enzyme-capacity constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
    # EnzymeConstraintDataTable.unset_attribute(&#39;Date&#39;)
    EnzymeConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    ProcessConstraintDataTable = self.ProcessConstraintData.toSBtab(
        table_id=&#39;machine_capacity_dual&#39;, table_type=&#39;QuantityMatrix&#39;, table_name=&#39;Machine capacity dual values&#39;)
    ProcessConstraintDataTable.filename = &#39;ProcessConstraintData.tsv&#39;
    ProcessConstraintDataTable.change_attribute(&#39;Unit&#39;, &#39;&#39;)
    ProcessConstraintDataTable.change_attribute(&#39;QuantityType&#39;, &#39;lagrange_multiplier&#39;)
    ProcessConstraintDataTable.change_attribute(
        &#39;Text&#39;, &#39;Shadow prices of the machine-capacity constraints obtained in the simulation runs (table columns). The measurement units of shadow prices are given by the measurement unit of objective function, divided by the measurement units of the respective constraints&#39;)
    # ProcessConstraintDataTable.unset_attribute(&#39;Date&#39;)
    ProcessConstraintDataTable.unset_attribute(&#39;SBtabVersion&#39;)

    if filename is not None:
        filename_SBtab = filename
    else:
        filename_SBtab = &#39;RBA_results&#39;

    if add_links:
        ReactionDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Reaction/&#39;+entry+&#39;!)&#39;)
                                                                 for entry in list(ReactionDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
        ProcessDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Process/&#39;+entry+&#39;!)&#39;)
                                                                for entry in list(ProcessDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
        EnzymeDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Enzyme/&#39;+entry+&#39;!)&#39;)
                                                               for entry in list(EnzymeDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
        ProteinDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(&#39;(!&#39;+&#39;Protein/&#39;+entry+&#39;!)&#39;)
                                                                for entry in list(ProteinDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
        MetaboliteConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
            &#39;(!&#39;+&#39;Compound/&#39;+entry+&#39;!)&#39;) for entry in list(MetaboliteConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
        DensityConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
            &#39;(!&#39;+&#39;Compartment/&#39;+entry+&#39;!)&#39;) for entry in list(DensityConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
        ProcessConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
            &#39;(!&#39;+&#39;Process/&#39;+entry+&#39;!)&#39;) for entry in list(ProcessConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)
        EnzymeConstraintDataTable.add_column(column_list=[&#39;!ElementID&#39;]+[str(
            &#39;(!&#39;+&#39;Enzyme/&#39;+entry+&#39;!)&#39;) for entry in list(EnzymeConstraintDataTable.to_data_frame()[&#39;ID&#39;])], position=1)

        filename_SBtab += &#39;_HTML&#39;

    else:
        ReactionDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(ReactionDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
        ProcessDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(ProcessDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
        EnzymeDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(EnzymeDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
        ProteinDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(ProteinDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
        MetaboliteConstraintDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(MetaboliteConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
        DensityConstraintDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(DensityConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
        ProcessConstraintDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(ProcessConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)
        EnzymeConstraintDataTable.add_column(
            column_list=[&#39;!ElementID&#39;]+list(EnzymeConstraintDataTable.to_data_frame()[&#39;ID&#39;]), position=1)

    ReactionDataTable.remove_column(position=2)
    ProcessDataTable.remove_column(position=2)
    EnzymeDataTable.remove_column(position=2)
    ProteinDataTable.remove_column(position=2)
    MetaboliteConstraintDataTable.remove_column(position=2)
    DensityConstraintDataTable.remove_column(position=2)
    ProcessConstraintDataTable.remove_column(position=2)
    EnzymeConstraintDataTable.remove_column(position=2)

    self.Out = SBtab.SBtabDocument(name=&#39;rbatools_SimulationData_withLinks&#39;,
                                   sbtab_init=None, filename=str(filename_SBtab+&#39;.tsv&#39;))
    self.Out.add_sbtab(GeneralRunInfoTable)
    self.Out.add_sbtab(ObjectiveFunctionDataTable)
    self.Out.add_sbtab(ReactionDataTable)
    self.Out.add_sbtab(EnzymeDataTable)
    self.Out.add_sbtab(ProcessDataTable)
    self.Out.add_sbtab(ProteinDataTable)
    self.Out.add_sbtab(MetaboliteConstraintDataTable)
    self.Out.add_sbtab(DensityConstraintDataTable)
    self.Out.add_sbtab(EnzymeConstraintDataTable)
    self.Out.add_sbtab(ProcessConstraintDataTable)

    self.Out.change_attribute(&#39;DocumentName&#39;, &#39;RBA data&#39;)
    self.Out.name = filename
    self.Out.change_attribute(&#39;DocumentType&#39;, &#39;rba-simulation-data&#39;)
    self.Out.write()</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.exportXML"><code class="name flex">
<span>def <span class="ident">exportXML</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Exports xml-file</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exportXML(self):
    &#34;&#34;&#34;
    Exports xml-file
    &#34;&#34;&#34;

    x = htmlStyle(self)
    root = ET.fromstring(jxmlease.emit_xml(x, encoding=&#39;utf-8&#39;))
    m = ET.tostring(root, &#39;utf-8&#39;)
    return(m)</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.fromJSON"><code class="name flex">
<span>def <span class="ident">fromJSON</span></span>(<span>self, inputString)</span>
</code></dt>
<dd>
<section class="desc"><p>Imports data from JSON string object
Parameters</p>
<hr>
<dl>
<dt><strong><code>inputString</code></strong> :&ensp;<code>json</code>-<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fromJSON(self, inputString):
    &#34;&#34;&#34;
    Imports data from JSON string object
    Parameters
    ----------
    inputString: json-string
    &#34;&#34;&#34;

    Block = json.loads(inputString)
    self.ReactionData = DataBlock()
    self.ProteinData = DataBlock()
    self.EnzymeData = DataBlock()
    self.ProcessData = DataBlock()
    self.MetaboliteConstraintData = DataBlock()
    self.DensityConstraintData = DataBlock()
    self.EnzymeConstraintData = DataBlock()
    self.ProcessConstraintData = DataBlock()
    self.ReactionData.fromDict(Block[&#39;ReactionData&#39;])
    self.ProteinData.fromDict(Block[&#39;ProteinData&#39;])
    self.EnzymeData.fromDict(Block[&#39;EnzymeData&#39;])
    self.ProcessData.fromDict(Block[&#39;ProcessData&#39;])
    self.MetaboliteConstraintData.fromDict(Block[&#39;MetaboliteConstraintData&#39;])
    self.DensityConstraintData.fromDict(Block[&#39;DensityConstraintData&#39;])
    self.EnzymeConstraintData.fromDict(Block[&#39;EnzymeConstraintData&#39;])
    self.ProcessConstraintData.fromDict(Block[&#39;ProcessConstraintData&#39;])</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.fromSimulationResults"><code class="name flex">
<span>def <span class="ident">fromSimulationResults</span></span>(<span>self, Controller, session_name=&#39;&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Imports data from rbatools.RBA_Controler object
Parameters</p>
<hr>
<dl>
<dt><strong><code>Controller</code></strong> :&ensp;<code>rbatools.RBA_newControler</code></dt>
<dd>Defines from which object to extract the data from</dd>
<dt><strong><code>session_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Defines the name of the session
Is appended to the filenames generated by export methods.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">    def fromSimulationResults(self, Controller, session_name=&#39;&#39;):
        &#34;&#34;&#34;
        Imports data from rbatools.RBA_Controler object
        Parameters
        ----------
        Controller : rbatools.RBA_newControler
            Defines from which object to extract the data from
        session_name: str
            Defines the name of the session
            Is appended to the filenames generated by export methods.
        &#34;&#34;&#34;
        self.SessionName = session_name

        self.run_names = list(Controller.Results[&#39;ObjectiveValue&#39;])
        ObjDict = {}
        for run in list(Controller.Results[&#39;ObjectiveValue&#39;]):
            ObjDict.update({run: Controller.Results[&#39;ObjectiveValue&#39;].loc[&#39;ObjectiveValue&#39;, run]})

        SolutionType_Dict = {}
        for run in list(Controller.Results[&#39;SolutionType&#39;]):
            SolutionType_Dict.update(
                {run: Controller.Results[&#39;SolutionType&#39;].loc[&#39;SolutionType&#39;, run]})

        MuDict = {}
        for run in list(Controller.Results[&#39;Mu&#39;]):
            MuDict.update({run: Controller.Results[&#39;Mu&#39;].loc[&#39;Mu&#39;, run]})

        self.GeneralRunInfo.addEntries({&#39;ProblemType&#39;: SolutionType_Dict})
        self.GeneralRunInfo.addEntries({&#39;Mu&#39;: MuDict})
        self.GeneralRunInfo.addEntries({&#39;Obj_Val&#39;: ObjDict})

        for var in list(Controller.Results[&#39;ObjectiveFunction&#39;].index):
            if var not in self.ObjectiveFunctionInfo.Elements:
                self.ObjectiveFunctionInfo.Elements.update({var: {}})
            for run in list(Controller.Results[&#39;ObjectiveFunction&#39;]):
                self.ObjectiveFunctionInfo.Elements[var].update(
                    {run: Controller.Results[&#39;ObjectiveFunction&#39;].loc[var, run]})

        for exchange in list(Controller.Results[&#39;ExchangeFluxes&#39;].index):
            if exchange not in self.ExchangeData.Elements:
                self.ExchangeData.Elements.update({exchange: {}})
#            self.ExchangeData.Elements[exchange].update({&#39;ID&#39;: exchange})
            for run in list(Controller.Results[&#39;ExchangeFluxes&#39;]):
                self.ExchangeData.Elements[exchange].update(
                    {run: Controller.Results[&#39;ExchangeFluxes&#39;].loc[exchange, run]})

        for reaction in list(Controller.Results[&#39;Reactions&#39;].index):
            if reaction not in self.ReactionData.Elements:
                self.ReactionData.Elements.update({reaction: {}})
#            self.ReactionData.Elements[reaction].update({&#39;ID&#39;: reaction})
            for run in list(Controller.Results[&#39;Reactions&#39;]):
                self.ReactionData.Elements[reaction].update(
                    {run: Controller.Results[&#39;Reactions&#39;].loc[reaction, run]})

        for reaction in list(Controller.Results[&#39;uniqueReactions&#39;].index):
            if reaction not in self.uniqueReactionData.Elements:
                self.uniqueReactionData.Elements.update({reaction: {}})
#            self.uniqueReactionData.Elements[reaction].update({&#39;ID&#39;: reaction})
            for run in list(Controller.Results[&#39;uniqueReactions&#39;]):
                self.uniqueReactionData.Elements[reaction].update(
                    {run: Controller.Results[&#39;uniqueReactions&#39;].loc[reaction, run]})

        for enzyme in list(Controller.Results[&#39;Enzymes&#39;].index):
            if enzyme not in self.EnzymeData.Elements:
                self.EnzymeData.Elements.update({enzyme: {}})
#            self.EnzymeData.Elements[enzyme].update({&#39;ID&#39;: enzyme})
            for run in list(Controller.Results[&#39;Enzymes&#39;]):
                self.EnzymeData.Elements[enzyme].update(
                    {run: Controller.Results[&#39;Enzymes&#39;].loc[enzyme, run]})

        for process in list(Controller.Results[&#39;Processes&#39;].index):
            if process not in self.ProcessData.Elements:
                self.ProcessData.Elements.update({process: {}})
#            self.ProcessData.Elements[process].update({&#39;ID&#39;: process})
            for run in list(Controller.Results[&#39;Processes&#39;]):
                self.ProcessData.Elements[process].update(
                    {run: Controller.Results[&#39;Processes&#39;].loc[process, run]})

        for protein in list(Controller.Results[&#39;Proteins&#39;].index):
            if protein not in self.ProteinData.Elements:
                self.ProteinData.Elements.update({protein: {}})
#            self.ProteinData.Elements[protein].update({&#39;ID&#39;: protein})
            for run in list(Controller.Results[&#39;Proteins&#39;]):
                self.ProteinData.Elements[protein].update(
                    {run: Controller.Results[&#39;Proteins&#39;].loc[protein, run]})

        for protoprotein in list(Controller.Results[&#39;ProtoProteins&#39;].index):
            if protoprotein not in self.ProtoProteinData.Elements:
                self.ProtoProteinData.Elements.update({protoprotein: {}})
#            self.ProtoProteinData.Elements[protoprotein].update({&#39;ID&#39;: protoprotein})
            for run in list(Controller.Results[&#39;ProtoProteins&#39;]):
                self.ProtoProteinData.Elements[protoprotein].update(
                    {run: Controller.Results[&#39;ProtoProteins&#39;].loc[protoprotein, run]})

        for constr in list(Controller.Results[&#39;Constraints&#39;].index):
            if constr in list(self.StructuralInformation.MetaboliteConstraintsInfo.Elements.keys()):
                if constr not in self.MetaboliteConstraintData.Elements:
                    self.MetaboliteConstraintData.Elements.update({constr: {}})
#                self.MetaboliteConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.MetaboliteConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.DensityConstraintsInfo.Elements.keys()):
                if constr not in self.DensityConstraintData.Elements:
                    self.DensityConstraintData.Elements.update({constr: {}})
#                self.DensityConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.DensityConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.EnzymeConstraintsInfo.Elements.keys()):
                if constr not in self.EnzymeConstraintData.Elements:
                    self.EnzymeConstraintData.Elements.update({constr: {}})
#                self.EnzymeConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.EnzymeConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})
            if constr in list(self.StructuralInformation.ProcessConstraintsInfo.Elements.keys()):
                if constr not in self.ProcessConstraintData.Elements:
                    self.ProcessConstraintData.Elements.update({constr: {}})
#                self.ProcessConstraintData.Elements[constr].update({&#39;ID&#39;: constr})
                for run in list(Controller.Results[&#39;Constraints&#39;]):
                    self.ProcessConstraintData.Elements[constr].update(
                        {run: Controller.Results[&#39;Constraints&#39;].loc[constr, run]})</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.getCSVFiles"><code class="name flex">
<span>def <span class="ident">getCSVFiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getCSVFiles(self):
    return self.csvs</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.getEscherMap"><code class="name flex">
<span>def <span class="ident">getEscherMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getEscherMap(self):
    return self.eschermap</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.getProteoMap"><code class="name flex">
<span>def <span class="ident">getProteoMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getProteoMap(self):
    return self.proteomap</code></pre>
</details>
</dd>
<dt id="rbatools.rba_SimulationData.RBA_SimulationData.getSBtabDoc"><code class="name flex">
<span>def <span class="ident">getSBtabDoc</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getSBtabDoc(self):
    return self.Out</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rbatools" href="index.html">rbatools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="rbatools.rba_SimulationData.determineInvestment" href="#rbatools.rba_SimulationData.determineInvestment">determineInvestment</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.htmlStyle" href="#rbatools.rba_SimulationData.htmlStyle">htmlStyle</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.htmlStyleAddingCol" href="#rbatools.rba_SimulationData.htmlStyleAddingCol">htmlStyleAddingCol</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.htmlStyleReplacingCol" href="#rbatools.rba_SimulationData.htmlStyleReplacingCol">htmlStyleReplacingCol</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rbatools.rba_SimulationData.RBA_SimulationData" href="#rbatools.rba_SimulationData.RBA_SimulationData">RBA_SimulationData</a></code></h4>
<ul class="">
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.__init__" href="#rbatools.rba_SimulationData.RBA_SimulationData.__init__">__init__</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.exportCSV" href="#rbatools.rba_SimulationData.RBA_SimulationData.exportCSV">exportCSV</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.exportEscherMap" href="#rbatools.rba_SimulationData.RBA_SimulationData.exportEscherMap">exportEscherMap</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.exportJSON" href="#rbatools.rba_SimulationData.RBA_SimulationData.exportJSON">exportJSON</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.exportProteoMap" href="#rbatools.rba_SimulationData.RBA_SimulationData.exportProteoMap">exportProteoMap</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.exportSBtab" href="#rbatools.rba_SimulationData.RBA_SimulationData.exportSBtab">exportSBtab</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.exportXML" href="#rbatools.rba_SimulationData.RBA_SimulationData.exportXML">exportXML</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.fromJSON" href="#rbatools.rba_SimulationData.RBA_SimulationData.fromJSON">fromJSON</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.fromSimulationResults" href="#rbatools.rba_SimulationData.RBA_SimulationData.fromSimulationResults">fromSimulationResults</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.getCSVFiles" href="#rbatools.rba_SimulationData.RBA_SimulationData.getCSVFiles">getCSVFiles</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.getEscherMap" href="#rbatools.rba_SimulationData.RBA_SimulationData.getEscherMap">getEscherMap</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.getProteoMap" href="#rbatools.rba_SimulationData.RBA_SimulationData.getProteoMap">getProteoMap</a></code></li>
<li><code><a title="rbatools.rba_SimulationData.RBA_SimulationData.getSBtabDoc" href="#rbatools.rba_SimulationData.RBA_SimulationData.getSBtabDoc">getSBtabDoc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
